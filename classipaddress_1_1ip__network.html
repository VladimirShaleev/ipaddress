<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ipaddress: ip_network Class Reference</title>
<link rel="icon" href="logo.svg" type="image/svg+xml" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/VladimirShaleev/ipaddress" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
  <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
  <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ipaddress<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classipaddress_1_1ip__network.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classipaddress_1_1ip__network-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ip_network Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class that encapsulates both IPv4 and IPv6 network functionalities.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ip-any-network_8hpp_source.html">ip-any-network.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aae313eaed592b63eaaf590112e018995" id="r_aae313eaed592b63eaaf590112e018995"><td class="memItemLeft" align="right" valign="top"><a id="aae313eaed592b63eaaf590112e018995" name="aae313eaed592b63eaaf590112e018995"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ip_address_type</b> = <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a></td></tr>
<tr class="memdesc:aae313eaed592b63eaaf590112e018995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a>, representing the IP address within the network. <br /></td></tr>
<tr class="separator:aae313eaed592b63eaaf590112e018995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32b243c2c2875801a77f7c2fd1a512" id="r_abc32b243c2c2875801a77f7c2fd1a512"><td class="memItemLeft" align="right" valign="top"><a id="abc32b243c2c2875801a77f7c2fd1a512" name="abc32b243c2c2875801a77f7c2fd1a512"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>uint_type</b> = <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a></td></tr>
<tr class="memdesc:abc32b243c2c2875801a77f7c2fd1a512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 128-bit unsigned integer type. <br /></td></tr>
<tr class="separator:abc32b243c2c2875801a77f7c2fd1a512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a841fbbfe98aa27a875d1e408bfaa461e" id="r_a841fbbfe98aa27a875d1e408bfaa461e"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="namespaceipaddress.html#a34b83b8852b7ca0e7e93cbf0034ed69d">ip_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a841fbbfe98aa27a875d1e408bfaa461e">version</a> () const noexcept</td></tr>
<tr class="memdesc:a841fbbfe98aa27a875d1e408bfaa461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IP version of the network.  <br /></td></tr>
<tr class="separator:a841fbbfe98aa27a875d1e408bfaa461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd6479c08209e28e1320a72f708686" id="r_ad4cd6479c08209e28e1320a72f708686"><td class="memItemLeft" align="right" valign="top">constexpr inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4cd6479c08209e28e1320a72f708686">prefixlen</a> () const noexcept</td></tr>
<tr class="memdesc:ad4cd6479c08209e28e1320a72f708686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the prefix length of this network.  <br /></td></tr>
<tr class="separator:ad4cd6479c08209e28e1320a72f708686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5427d434a57be5e6ec7b3f46fff02851" id="r_a5427d434a57be5e6ec7b3f46fff02851"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5427d434a57be5e6ec7b3f46fff02851">network_address</a> () const noexcept</td></tr>
<tr class="memdesc:a5427d434a57be5e6ec7b3f46fff02851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the network address of this network.  <br /></td></tr>
<tr class="separator:a5427d434a57be5e6ec7b3f46fff02851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fed18a953698a9741c679885e26d16" id="r_aa4fed18a953698a9741c679885e26d16"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4fed18a953698a9741c679885e26d16">broadcast_address</a> () const noexcept</td></tr>
<tr class="memdesc:aa4fed18a953698a9741c679885e26d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the broadcast address of this network.  <br /></td></tr>
<tr class="separator:aa4fed18a953698a9741c679885e26d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359d9dd848ad160c0cda59cd1eebb416" id="r_a359d9dd848ad160c0cda59cd1eebb416"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359d9dd848ad160c0cda59cd1eebb416">netmask</a> () const noexcept</td></tr>
<tr class="memdesc:a359d9dd848ad160c0cda59cd1eebb416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the netmask of this network.  <br /></td></tr>
<tr class="separator:a359d9dd848ad160c0cda59cd1eebb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c4b45cf961b47a37da2164c0cc9808" id="r_a06c4b45cf961b47a37da2164c0cc9808"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06c4b45cf961b47a37da2164c0cc9808">hostmask</a> () const noexcept</td></tr>
<tr class="memdesc:a06c4b45cf961b47a37da2164c0cc9808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hostmask of this network.  <br /></td></tr>
<tr class="separator:a06c4b45cf961b47a37da2164c0cc9808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d509ad04e4e88eea0d5f21037632ca" id="r_a28d509ad04e4e88eea0d5f21037632ca"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28d509ad04e4e88eea0d5f21037632ca">is_multicast</a> () const noexcept</td></tr>
<tr class="memdesc:a28d509ad04e4e88eea0d5f21037632ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a multicast network.  <br /></td></tr>
<tr class="separator:a28d509ad04e4e88eea0d5f21037632ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c5dfb1a24f7a177abe288df2fe1b4b" id="r_a30c5dfb1a24f7a177abe288df2fe1b4b"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30c5dfb1a24f7a177abe288df2fe1b4b">is_private</a> () const noexcept</td></tr>
<tr class="memdesc:a30c5dfb1a24f7a177abe288df2fe1b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a private network.  <br /></td></tr>
<tr class="separator:a30c5dfb1a24f7a177abe288df2fe1b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0a20a93632cde3137e0ddd2b51e4f5" id="r_a9c0a20a93632cde3137e0ddd2b51e4f5"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c0a20a93632cde3137e0ddd2b51e4f5">is_global</a> () const noexcept</td></tr>
<tr class="memdesc:a9c0a20a93632cde3137e0ddd2b51e4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a global network.  <br /></td></tr>
<tr class="separator:a9c0a20a93632cde3137e0ddd2b51e4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4087941a260e1e8471dcaf9aa900c94d" id="r_a4087941a260e1e8471dcaf9aa900c94d"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4087941a260e1e8471dcaf9aa900c94d">is_reserved</a> () const noexcept</td></tr>
<tr class="memdesc:a4087941a260e1e8471dcaf9aa900c94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a reserved network.  <br /></td></tr>
<tr class="separator:a4087941a260e1e8471dcaf9aa900c94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e93e8e8ea4eebf9ae51e6d1bfefaf" id="r_ae32e93e8e8ea4eebf9ae51e6d1bfefaf"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae32e93e8e8ea4eebf9ae51e6d1bfefaf">is_loopback</a> () const noexcept</td></tr>
<tr class="memdesc:ae32e93e8e8ea4eebf9ae51e6d1bfefaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a loopback network.  <br /></td></tr>
<tr class="separator:ae32e93e8e8ea4eebf9ae51e6d1bfefaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48625896416a27deb6f4b131c4dbffbd" id="r_a48625896416a27deb6f4b131c4dbffbd"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48625896416a27deb6f4b131c4dbffbd">is_link_local</a> () const noexcept</td></tr>
<tr class="memdesc:a48625896416a27deb6f4b131c4dbffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a link-local network.  <br /></td></tr>
<tr class="separator:a48625896416a27deb6f4b131c4dbffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfed15a9f11a663033a52142e71bc26" id="r_a8bfed15a9f11a663033a52142e71bc26"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bfed15a9f11a663033a52142e71bc26">is_unspecified</a> () const noexcept</td></tr>
<tr class="memdesc:a8bfed15a9f11a663033a52142e71bc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is an unspecified network.  <br /></td></tr>
<tr class="separator:a8bfed15a9f11a663033a52142e71bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6814229a8f19ef2dfc6d7a63354149" id="r_a0e6814229a8f19ef2dfc6d7a63354149"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e6814229a8f19ef2dfc6d7a63354149">is_site_local</a> () const noexcept</td></tr>
<tr class="memdesc:a0e6814229a8f19ef2dfc6d7a63354149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the IPv6 network is site-local.  <br /></td></tr>
<tr class="separator:a0e6814229a8f19ef2dfc6d7a63354149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544ca2d18bbf0fe0e452701399ebb22" id="r_a0544ca2d18bbf0fe0e452701399ebb22"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0544ca2d18bbf0fe0e452701399ebb22">is_v4</a> () const noexcept</td></tr>
<tr class="memdesc:a0544ca2d18bbf0fe0e452701399ebb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the IP network is an IPv4 network.  <br /></td></tr>
<tr class="separator:a0544ca2d18bbf0fe0e452701399ebb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af086b3a9406a084819db7f07936034b4" id="r_af086b3a9406a084819db7f07936034b4"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af086b3a9406a084819db7f07936034b4">is_v6</a> () const noexcept</td></tr>
<tr class="memdesc:af086b3a9406a084819db7f07936034b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the IP network is an IPv6 network.  <br /></td></tr>
<tr class="separator:af086b3a9406a084819db7f07936034b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8890d890b4f300bbfa21071f23760b4" id="r_ad8890d890b4f300bbfa21071f23760b4"><td class="memItemLeft" align="right" valign="top">constexpr inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8890d890b4f300bbfa21071f23760b4">size</a> () const noexcept</td></tr>
<tr class="memdesc:ad8890d890b4f300bbfa21071f23760b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the IP address.  <br /></td></tr>
<tr class="separator:ad8890d890b4f300bbfa21071f23760b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea6c821fe871e802647d69810a470d" id="r_ab4ea6c821fe871e802647d69810a470d"><td class="memItemLeft" align="right" valign="top">constexpr inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ea6c821fe871e802647d69810a470d">hash</a> () const noexcept</td></tr>
<tr class="memdesc:ab4ea6c821fe871e802647d69810a470d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash value for the IP address.  <br /></td></tr>
<tr class="separator:ab4ea6c821fe871e802647d69810a470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b884d1774efbbc648e13abc90efc43" id="r_a44b884d1774efbbc648e13abc90efc43"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44b884d1774efbbc648e13abc90efc43">addresses_count</a> () const noexcept</td></tr>
<tr class="memdesc:a44b884d1774efbbc648e13abc90efc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total number of addresses in the network.  <br /></td></tr>
<tr class="separator:a44b884d1774efbbc648e13abc90efc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947263a137b931017d2c3b1012d7d831" id="r_a947263a137b931017d2c3b1012d7d831"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947263a137b931017d2c3b1012d7d831">contains</a> (const <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> &amp;address) const noexcept</td></tr>
<tr class="memdesc:a947263a137b931017d2c3b1012d7d831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given IP address is contained within this network.  <br /></td></tr>
<tr class="separator:a947263a137b931017d2c3b1012d7d831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ddaec67a3a14e19371900f207d753d" id="r_ab4ddaec67a3a14e19371900f207d753d"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ddaec67a3a14e19371900f207d753d">overlaps</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:ab4ddaec67a3a14e19371900f207d753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this network overlaps with another network.  <br /></td></tr>
<tr class="separator:ab4ddaec67a3a14e19371900f207d753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3388c3cd2b15e9d6800eeae91f4d0797" id="r_a3388c3cd2b15e9d6800eeae91f4d0797"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3388c3cd2b15e9d6800eeae91f4d0797">subnet_of</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a3388c3cd2b15e9d6800eeae91f4d0797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this network is a subnet of another network.  <br /></td></tr>
<tr class="separator:a3388c3cd2b15e9d6800eeae91f4d0797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a37309e62e498d68811df908904c328" id="r_a9a37309e62e498d68811df908904c328"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a37309e62e498d68811df908904c328">supernet_of</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a9a37309e62e498d68811df908904c328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this network is a supernet of another network.  <br /></td></tr>
<tr class="separator:a9a37309e62e498d68811df908904c328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1288f457a02658d5bc47c121b7a2d6b" id="r_ab1288f457a02658d5bc47c121b7a2d6b"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1hosts__any__sequence.html">hosts_any_sequence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1288f457a02658d5bc47c121b7a2d6b">hosts</a> () const noexcept</td></tr>
<tr class="memdesc:ab1288f457a02658d5bc47c121b7a2d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a sequence of host addresses in the network.  <br /></td></tr>
<tr class="separator:ab1288f457a02658d5bc47c121b7a2d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7607994f130363d19b51aa5aa661c24a" id="r_a7607994f130363d19b51aa5aa661c24a"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1subnets__any__sequence.html">subnets_any_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7607994f130363d19b51aa5aa661c24a">subnets</a> (size_t prefixlen_diff=1, <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt; new_prefixlen=nullptr) const</td></tr>
<tr class="memdesc:a7607994f130363d19b51aa5aa661c24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of subnets from this network.  <br /></td></tr>
<tr class="separator:a7607994f130363d19b51aa5aa661c24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f48ce59958e8eee935eb1196edce2fa" id="r_a1f48ce59958e8eee935eb1196edce2fa"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1subnets__any__sequence.html">subnets_any_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f48ce59958e8eee935eb1196edce2fa">subnets</a> (<a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, size_t prefixlen_diff=1, <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt; new_prefixlen=nullptr) const noexcept</td></tr>
<tr class="memdesc:a1f48ce59958e8eee935eb1196edce2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of subnets from this network with error handling.  <br /></td></tr>
<tr class="separator:a1f48ce59958e8eee935eb1196edce2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfed79e42747c3a087a1e7e338895a4a" id="r_adfed79e42747c3a087a1e7e338895a4a"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfed79e42747c3a087a1e7e338895a4a">address_exclude</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;other) const</td></tr>
<tr class="memdesc:adfed79e42747c3a087a1e7e338895a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the network definitions resulting from removing the given network from this one.  <br /></td></tr>
<tr class="separator:adfed79e42747c3a087a1e7e338895a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33b915d7fbd38b2811c3da45e2cd040" id="r_ad33b915d7fbd38b2811c3da45e2cd040"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad33b915d7fbd38b2811c3da45e2cd040">address_exclude</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;other, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code) const noexcept</td></tr>
<tr class="memdesc:ad33b915d7fbd38b2811c3da45e2cd040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the network definitions resulting from removing the given network from this one, with error handling.  <br /></td></tr>
<tr class="separator:ad33b915d7fbd38b2811c3da45e2cd040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae063b5c983c82062126fd59b96ed65dc" id="r_ae063b5c983c82062126fd59b96ed65dc"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; <a class="el" href="namespaceipaddress.html#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae063b5c983c82062126fd59b96ed65dc">v4</a> () const noexcept</td></tr>
<tr class="memdesc:ae063b5c983c82062126fd59b96ed65dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IPv4 network.  <br /></td></tr>
<tr class="separator:ae063b5c983c82062126fd59b96ed65dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb478d3edc31e5fec89d6a0de9145beb" id="r_acb478d3edc31e5fec89d6a0de9145beb"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; <a class="el" href="namespaceipaddress.html#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb478d3edc31e5fec89d6a0de9145beb">v6</a> () const noexcept</td></tr>
<tr class="memdesc:acb478d3edc31e5fec89d6a0de9145beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IPv6 network.  <br /></td></tr>
<tr class="separator:acb478d3edc31e5fec89d6a0de9145beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a72b117b04d4e4b6e22c9d30014a84" id="r_a71a72b117b04d4e4b6e22c9d30014a84"><td class="memItemLeft" align="right" valign="top">constexpr inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71a72b117b04d4e4b6e22c9d30014a84">ip_network</a> () noexcept</td></tr>
<tr class="memdesc:a71a72b117b04d4e4b6e22c9d30014a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new IP network object.  <br /></td></tr>
<tr class="separator:a71a72b117b04d4e4b6e22c9d30014a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f199e32db23c59f56dcc0f58241de58" id="r_a1f199e32db23c59f56dcc0f58241de58"><td class="memItemLeft" align="right" valign="top">constexpr inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f199e32db23c59f56dcc0f58241de58">ip_network</a> (const <a class="el" href="namespaceipaddress.html#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> &amp;net4) noexcept</td></tr>
<tr class="memdesc:a1f199e32db23c59f56dcc0f58241de58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an ipv4_network.  <br /></td></tr>
<tr class="separator:a1f199e32db23c59f56dcc0f58241de58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c98382ef404c84eb406eadcc8c6b0" id="r_aff8c98382ef404c84eb406eadcc8c6b0"><td class="memItemLeft" align="right" valign="top">constexpr inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8c98382ef404c84eb406eadcc8c6b0">ip_network</a> (const <a class="el" href="namespaceipaddress.html#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> &amp;net6) noexcept</td></tr>
<tr class="memdesc:aff8c98382ef404c84eb406eadcc8c6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an ipv6_network.  <br /></td></tr>
<tr class="separator:aff8c98382ef404c84eb406eadcc8c6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c89e293118ded7cd33e0f0395cbd62" id="r_ae5c89e293118ded7cd33e0f0395cbd62"><td class="memItemLeft" align="right" valign="top">inline std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5c89e293118ded7cd33e0f0395cbd62">to_string</a> (<a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eb">format</a> fmt=<a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672">format::compressed</a>) const</td></tr>
<tr class="memdesc:ae5c89e293118ded7cd33e0f0395cbd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the network to a string representation.  <br /></td></tr>
<tr class="separator:ae5c89e293118ded7cd33e0f0395cbd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b1372b4325fb657c316348be6a8139" id="r_a00b1372b4325fb657c316348be6a8139"><td class="memItemLeft" align="right" valign="top">constexpr inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00b1372b4325fb657c316348be6a8139">swap</a> (<a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;net) noexcept</td></tr>
<tr class="memdesc:a00b1372b4325fb657c316348be6a8139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this network with another network.  <br /></td></tr>
<tr class="separator:a00b1372b4325fb657c316348be6a8139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c561d99ae9901e0d42d503cea43a3" id="r_a177c561d99ae9901e0d42d503cea43a3"><td class="memItemLeft" align="right" valign="top">inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a177c561d99ae9901e0d42d503cea43a3">operator std::string</a> () const</td></tr>
<tr class="memdesc:a177c561d99ae9901e0d42d503cea43a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the ip network object to a std::string.  <br /></td></tr>
<tr class="separator:a177c561d99ae9901e0d42d503cea43a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef898a03a2ede8c01fed40c932351ef" id="r_a4ef898a03a2ede8c01fed40c932351ef"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef898a03a2ede8c01fed40c932351ef">operator==</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a4ef898a03a2ede8c01fed40c932351ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <br /></td></tr>
<tr class="separator:a4ef898a03a2ede8c01fed40c932351ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c14c5004c8c0ccfd33c7d7c4ba962d" id="r_aa9c14c5004c8c0ccfd33c7d7c4ba962d"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c14c5004c8c0ccfd33c7d7c4ba962d">operator!=</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aa9c14c5004c8c0ccfd33c7d7c4ba962d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator.  <br /></td></tr>
<tr class="separator:aa9c14c5004c8c0ccfd33c7d7c4ba962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac614e54e8c4d7f1911c5f79e86a36acd" id="r_ac614e54e8c4d7f1911c5f79e86a36acd"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac614e54e8c4d7f1911c5f79e86a36acd">operator&lt;</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ac614e54e8c4d7f1911c5f79e86a36acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than comparison operator.  <br /></td></tr>
<tr class="separator:ac614e54e8c4d7f1911c5f79e86a36acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d7715958b91ca4482f21e1d60dc055" id="r_a52d7715958b91ca4482f21e1d60dc055"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52d7715958b91ca4482f21e1d60dc055">operator&gt;</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a52d7715958b91ca4482f21e1d60dc055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than comparison operator.  <br /></td></tr>
<tr class="separator:a52d7715958b91ca4482f21e1d60dc055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a53b855482d8c9ac7f94df4d06046d" id="r_a31a53b855482d8c9ac7f94df4d06046d"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31a53b855482d8c9ac7f94df4d06046d">operator&lt;=</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a31a53b855482d8c9ac7f94df4d06046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to comparison operator.  <br /></td></tr>
<tr class="separator:a31a53b855482d8c9ac7f94df4d06046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01df7f12b3209c650d7391e7e8f94762" id="r_a01df7f12b3209c650d7391e7e8f94762"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01df7f12b3209c650d7391e7e8f94762">operator&gt;=</a> (const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a01df7f12b3209c650d7391e7e8f94762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to comparison operator.  <br /></td></tr>
<tr class="separator:a01df7f12b3209c650d7391e7e8f94762"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7eb26d7695f6dbc1276ade0dbb7d3453" id="r_a7eb26d7695f6dbc1276ade0dbb7d3453"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eb26d7695f6dbc1276ade0dbb7d3453">from_address</a> (const <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> &amp;address, size_t <a class="el" href="#ad4cd6479c08209e28e1320a72f708686">prefixlen</a>, bool strict=true)</td></tr>
<tr class="memdesc:a7eb26d7695f6dbc1276ade0dbb7d3453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ip network object from a given IP address and prefix length.  <br /></td></tr>
<tr class="separator:a7eb26d7695f6dbc1276ade0dbb7d3453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8ea0801c6190f7d0ddf8f71664e588" id="r_a2c8ea0801c6190f7d0ddf8f71664e588"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8ea0801c6190f7d0ddf8f71664e588">from_address</a> (const <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> &amp;address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, size_t <a class="el" href="#ad4cd6479c08209e28e1320a72f708686">prefixlen</a>, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a2c8ea0801c6190f7d0ddf8f71664e588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ip network object from a given IP address and prefix length, with error handling.  <br /></td></tr>
<tr class="separator:a2c8ea0801c6190f7d0ddf8f71664e588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1680eeca5814f1e58ee81fc3de5d20df" id="r_a1680eeca5814f1e58ee81fc3de5d20df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString, bool Strict = true&gt; </td></tr>
<tr class="memitem:a1680eeca5814f1e58ee81fc3de5d20df"><td class="memTemplItemLeft" align="right" valign="top">static consteval inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1680eeca5814f1e58ee81fc3de5d20df">parse</a> () noexcept</td></tr>
<tr class="memdesc:a1680eeca5814f1e58ee81fc3de5d20df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a fixed string at compile time.  <br /></td></tr>
<tr class="separator:a1680eeca5814f1e58ee81fc3de5d20df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0126c09bbd350d0cca794727ab2ac4eb" id="r_a0126c09bbd350d0cca794727ab2ac4eb"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0126c09bbd350d0cca794727ab2ac4eb">parse</a> (std::string_view address, bool strict=true)</td></tr>
<tr class="memdesc:a0126c09bbd350d0cca794727ab2ac4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a string view.  <br /></td></tr>
<tr class="separator:a0126c09bbd350d0cca794727ab2ac4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda48a8a649cc76ea319229dfa3671d8" id="r_acda48a8a649cc76ea319229dfa3671d8"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda48a8a649cc76ea319229dfa3671d8">parse</a> (std::wstring_view address, bool strict=true)</td></tr>
<tr class="memdesc:acda48a8a649cc76ea319229dfa3671d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a wide string view.  <br /></td></tr>
<tr class="separator:acda48a8a649cc76ea319229dfa3671d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ff9fb93131df0190e1e749398c77c0" id="r_ad7ff9fb93131df0190e1e749398c77c0"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7ff9fb93131df0190e1e749398c77c0">parse</a> (std::u8string_view address, bool strict=true)</td></tr>
<tr class="memdesc:ad7ff9fb93131df0190e1e749398c77c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-8 string view.  <br /></td></tr>
<tr class="separator:ad7ff9fb93131df0190e1e749398c77c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2915718e70c297a8b76394590e5c0999" id="r_a2915718e70c297a8b76394590e5c0999"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2915718e70c297a8b76394590e5c0999">parse</a> (std::u16string_view address, bool strict=true)</td></tr>
<tr class="memdesc:a2915718e70c297a8b76394590e5c0999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-16 string view.  <br /></td></tr>
<tr class="separator:a2915718e70c297a8b76394590e5c0999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a16d08818536742cbc6db98aa5c37b" id="r_a96a16d08818536742cbc6db98aa5c37b"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a16d08818536742cbc6db98aa5c37b">parse</a> (std::u32string_view address, bool strict=true)</td></tr>
<tr class="memdesc:a96a16d08818536742cbc6db98aa5c37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-32 string view.  <br /></td></tr>
<tr class="separator:a96a16d08818536742cbc6db98aa5c37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5404cb00599c2ee19e34546c192bc1a9" id="r_a5404cb00599c2ee19e34546c192bc1a9"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5404cb00599c2ee19e34546c192bc1a9">parse</a> (std::string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a5404cb00599c2ee19e34546c192bc1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a string view with error handling.  <br /></td></tr>
<tr class="separator:a5404cb00599c2ee19e34546c192bc1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da72c9d5861a2d8f6792a9773170f23" id="r_a3da72c9d5861a2d8f6792a9773170f23"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3da72c9d5861a2d8f6792a9773170f23">parse</a> (std::wstring_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a3da72c9d5861a2d8f6792a9773170f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a wide string view with error handling.  <br /></td></tr>
<tr class="separator:a3da72c9d5861a2d8f6792a9773170f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1374f2493d333f77158cf5dfa0c1ce7" id="r_ab1374f2493d333f77158cf5dfa0c1ce7"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1374f2493d333f77158cf5dfa0c1ce7">parse</a> (std::u8string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:ab1374f2493d333f77158cf5dfa0c1ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-8 string view with error handling.  <br /></td></tr>
<tr class="separator:ab1374f2493d333f77158cf5dfa0c1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6af4ee373a8b570edb52dd350baeb1" id="r_a1e6af4ee373a8b570edb52dd350baeb1"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e6af4ee373a8b570edb52dd350baeb1">parse</a> (std::u16string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a1e6af4ee373a8b570edb52dd350baeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-16 string view with error handling.  <br /></td></tr>
<tr class="separator:a1e6af4ee373a8b570edb52dd350baeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a108ef4f69c7fd3285e9ef7460055c" id="r_a79a108ef4f69c7fd3285e9ef7460055c"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79a108ef4f69c7fd3285e9ef7460055c">parse</a> (std::u32string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a79a108ef4f69c7fd3285e9ef7460055c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-32 string view with error handling.  <br /></td></tr>
<tr class="separator:a79a108ef4f69c7fd3285e9ef7460055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6771535ee5da9f99aab7ea6c5470e1" id="r_a9e6771535ee5da9f99aab7ea6c5470e1"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9e6771535ee5da9f99aab7ea6c5470e1"><td class="memTemplItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e6771535ee5da9f99aab7ea6c5470e1">parse</a> (const T(&amp;address)[N], bool strict=true)</td></tr>
<tr class="memdesc:a9e6771535ee5da9f99aab7ea6c5470e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a character array.  <br /></td></tr>
<tr class="separator:a9e6771535ee5da9f99aab7ea6c5470e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd094fe87a4508afca91262df55f82a" id="r_a8dd094fe87a4508afca91262df55f82a"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a8dd094fe87a4508afca91262df55f82a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dd094fe87a4508afca91262df55f82a">parse</a> (const T(&amp;address)[N], <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a8dd094fe87a4508afca91262df55f82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a character array and reports errors through an error code.  <br /></td></tr>
<tr class="separator:a8dd094fe87a4508afca91262df55f82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that encapsulates both IPv4 and IPv6 network functionalities. </p>
<p>The <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> class serves as a versatile tool for network address manipulation, capable of handling both IPv4 and IPv6 networks. It abstracts the complexities associated with the different IP versions and provides a consistent API for network operations. This class is essential for applications that require flexibility in dealing with various IP network types without concern for the underlying IP version. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a71a72b117b04d4e4b6e22c9d30014a84" name="a71a72b117b04d4e4b6e22c9d30014a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a72b117b04d4e4b6e22c9d30014a84">&#9670;&#160;</a></span>ip_network() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new IP network object. </p>
<p>Initializes a new instance of the <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> class with the maximum prefix length for the IPv4 address, effectively setting the network address to the default address and the netmask to the maximum value. </p>

</div>
</div>
<a id="a1f199e32db23c59f56dcc0f58241de58" name="a1f199e32db23c59f56dcc0f58241de58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f199e32db23c59f56dcc0f58241de58">&#9670;&#160;</a></span>ip_network() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipaddress.html#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>net4</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an ipv4_network. </p>
<p>Constructs an <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object with the specified IPv4 network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net4</td><td>An ipv4_network object to initialize the <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff8c98382ef404c84eb406eadcc8c6b0" name="aff8c98382ef404c84eb406eadcc8c6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8c98382ef404c84eb406eadcc8c6b0">&#9670;&#160;</a></span>ip_network() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipaddress.html#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>net6</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from an ipv6_network. </p>
<p>Constructs an <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object with the specified IPv6 network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net6</td><td>An ipv6_network object to initialize the <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a841fbbfe98aa27a875d1e408bfaa461e" name="a841fbbfe98aa27a875d1e408bfaa461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841fbbfe98aa27a875d1e408bfaa461e">&#9670;&#160;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="namespaceipaddress.html#a34b83b8852b7ca0e7e93cbf0034ed69d">ip_version</a> version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the IP version of the network. </p>
<dl class="section return"><dt>Returns</dt><dd>The IP version as an enumeration (either V4 or V6). </dd></dl>

</div>
</div>
<a id="ad4cd6479c08209e28e1320a72f708686" name="ad4cd6479c08209e28e1320a72f708686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cd6479c08209e28e1320a72f708686">&#9670;&#160;</a></span>prefixlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline size_t prefixlen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the prefix length of this network. </p>
<p>This method returns the prefix length of the network. The prefix length is the number of bits in the network address portion of the IP address and is used to calculate the netmask.</p>
<dl class="section return"><dt>Returns</dt><dd>The prefix length of the network as a size_t value. </dd></dl>

</div>
</div>
<a id="a5427d434a57be5e6ec7b3f46fff02851" name="a5427d434a57be5e6ec7b3f46fff02851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5427d434a57be5e6ec7b3f46fff02851">&#9670;&#160;</a></span>network_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> network_address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the network address of this network. </p>
<p>This method returns the network address component of the ip network object.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the network address. </dd></dl>

</div>
</div>
<a id="aa4fed18a953698a9741c679885e26d16" name="aa4fed18a953698a9741c679885e26d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fed18a953698a9741c679885e26d16">&#9670;&#160;</a></span>broadcast_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> broadcast_address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the broadcast address of this network. </p>
<p>The broadcast address is the last address in the network and is used to communicate with all hosts on this network.</p>
<dl class="section return"><dt>Returns</dt><dd>The broadcast address of the network as an <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a> object. </dd></dl>

</div>
</div>
<a id="a359d9dd848ad160c0cda59cd1eebb416" name="a359d9dd848ad160c0cda59cd1eebb416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359d9dd848ad160c0cda59cd1eebb416">&#9670;&#160;</a></span>netmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> netmask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the netmask of this network. </p>
<p>This method returns the netmask of the network. The netmask is used to determine which portion of an IP address is the network portion and which is the host portion.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the netmask as an <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a> object. </dd></dl>

</div>
</div>
<a id="a06c4b45cf961b47a37da2164c0cc9808" name="a06c4b45cf961b47a37da2164c0cc9808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c4b45cf961b47a37da2164c0cc9808">&#9670;&#160;</a></span>hostmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> hostmask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hostmask of this network. </p>
<p>The hostmask identifies the portion of the IP address that is allocated for host identifiers.</p>
<dl class="section return"><dt>Returns</dt><dd>The hostmask of the network as an <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a> object. </dd></dl>

</div>
</div>
<a id="a28d509ad04e4e88eea0d5f21037632ca" name="a28d509ad04e4e88eea0d5f21037632ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d509ad04e4e88eea0d5f21037632ca">&#9670;&#160;</a></span>is_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_multicast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a multicast network. </p>
<p>This method determines whether the network is a multicast network by checking if both the network address and the broadcast address are multicast addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is multicast, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc3171.html">RFC 3171</a> for IPv4. </dd>
<dd>
<a href="https://datatracker.ietf.org/doc/html/rfc2373.html">RFC 2373</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a30c5dfb1a24f7a177abe288df2fe1b4b" name="a30c5dfb1a24f7a177abe288df2fe1b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c5dfb1a24f7a177abe288df2fe1b4b">&#9670;&#160;</a></span>is_private()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_private </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a private network. </p>
<p>This method determines whether the network is a private network. Private networks are not routed on the global internet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is private, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">iana-ipv4-special-registry</a>. </dd>
<dd>
<a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">iana-ipv6-special-registry</a>. </dd></dl>

</div>
</div>
<a id="a9c0a20a93632cde3137e0ddd2b51e4f5" name="a9c0a20a93632cde3137e0ddd2b51e4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0a20a93632cde3137e0ddd2b51e4f5">&#9670;&#160;</a></span>is_global()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_global </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a global network. </p>
<p>This method determines whether the network is a global network. Global networks are routable on the internet and are not private.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is global, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">iana-ipv4-special-registry</a>. </dd>
<dd>
<a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">iana-ipv6-special-registry</a>. </dd></dl>

</div>
</div>
<a id="a4087941a260e1e8471dcaf9aa900c94d" name="a4087941a260e1e8471dcaf9aa900c94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4087941a260e1e8471dcaf9aa900c94d">&#9670;&#160;</a></span>is_reserved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_reserved </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a reserved network. </p>
<p>This method determines whether the network is reserved by checking if both the network address and the broadcast address are reserved addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is reserved, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae32e93e8e8ea4eebf9ae51e6d1bfefaf" name="ae32e93e8e8ea4eebf9ae51e6d1bfefaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32e93e8e8ea4eebf9ae51e6d1bfefaf">&#9670;&#160;</a></span>is_loopback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_loopback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a loopback network. </p>
<p>This method determines whether the network is a loopback network by checking if both the network address and the broadcast address are loopback addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is loopback, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc3330.html">RFC 3330</a> for IPv4. </dd>
<dd>
<a href="https://datatracker.ietf.org/doc/html/rfc2373.html">RFC 2373</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a48625896416a27deb6f4b131c4dbffbd" name="a48625896416a27deb6f4b131c4dbffbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48625896416a27deb6f4b131c4dbffbd">&#9670;&#160;</a></span>is_link_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_link_local </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a link-local network. </p>
<p>This method determines whether the network is a link-local network by checking if both the network address and the broadcast address are link-local addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is link-local, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc3927.html">RFC 3927</a>. </dd></dl>

</div>
</div>
<a id="a8bfed15a9f11a663033a52142e71bc26" name="a8bfed15a9f11a663033a52142e71bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfed15a9f11a663033a52142e71bc26">&#9670;&#160;</a></span>is_unspecified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_unspecified </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is an unspecified network. </p>
<p>This method determines whether the network is unspecified by checking if both the network address and the broadcast address are unspecified addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is unspecified, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc5735.html">RFC 5735</a> for IPv4. </dd>
<dd>
<a href="https://datatracker.ietf.org/doc/html/rfc2373.html">RFC 2373</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a0e6814229a8f19ef2dfc6d7a63354149" name="a0e6814229a8f19ef2dfc6d7a63354149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6814229a8f19ef2dfc6d7a63354149">&#9670;&#160;</a></span>is_site_local()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_site_local </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the IPv6 network is site-local. </p>
<p>This method determines if both the network address and the broadcast address of the IPv6 network are site-local, which are addresses used within a particular organization's intranet and are not routable on the global internet.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether the network is site-local. </dd></dl>

</div>
</div>
<a id="a0544ca2d18bbf0fe0e452701399ebb22" name="a0544ca2d18bbf0fe0e452701399ebb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544ca2d18bbf0fe0e452701399ebb22">&#9670;&#160;</a></span>is_v4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_v4 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the IP network is an IPv4 network. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the IP network is an IPv4 network, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af086b3a9406a084819db7f07936034b4" name="af086b3a9406a084819db7f07936034b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af086b3a9406a084819db7f07936034b4">&#9670;&#160;</a></span>is_v6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_v6 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the IP network is an IPv6 network. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the IP network is an IPv6 network, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad8890d890b4f300bbfa21071f23760b4" name="ad8890d890b4f300bbfa21071f23760b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8890d890b4f300bbfa21071f23760b4">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline size_t size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the size of the IP address. </p>
<p>Depending on the IP version, this function returns the size of the IPv4 or IPv6 address.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the IP address in bytes. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is the number of bytes of the IP address that represents the current network. </dd></dl>

</div>
</div>
<a id="ab4ea6c821fe871e802647d69810a470d" name="ab4ea6c821fe871e802647d69810a470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea6c821fe871e802647d69810a470d">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline size_t hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a hash value for the IP address. </p>
<p>This function generates a hash value that can be used to uniquely identify the IP address. It can be useful when IP addresses are used as keys in hash tables.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>size_t</code> hash value of the IP address. </dd></dl>

</div>
</div>
<a id="a44b884d1774efbbc648e13abc90efc43" name="a44b884d1774efbbc648e13abc90efc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b884d1774efbbc648e13abc90efc43">&#9670;&#160;</a></span>addresses_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> addresses_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the total number of addresses in the network. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of addresses in the network as a <code><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a></code> value. </dd></dl>

</div>
</div>
<a id="a947263a137b931017d2c3b1012d7d831" name="a947263a137b931017d2c3b1012d7d831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947263a137b931017d2c3b1012d7d831">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given IP address is contained within this network. </p>
<p>This method determines whether the provided IP address is part of the network represented by this ip network object, based on the network address and netmask.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result1 = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>).<a class="code hl_function" href="#a947263a137b931017d2c3b1012d7d831">contains</a>(<a class="code hl_function" href="classipaddress_1_1ip__address.html#aa734f67f653b6979f7c359ead8202fdf">ip_address::parse</a>(<span class="stringliteral">&quot;192.0.2.6&quot;</span>));</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result2 = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>).<a class="code hl_function" href="#a947263a137b931017d2c3b1012d7d831">contains</a>(<a class="code hl_function" href="classipaddress_1_1ip__address.html#aa734f67f653b6979f7c359ead8202fdf">ip_address::parse</a>(<span class="stringliteral">&quot;192.0.3.6&quot;</span>));</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; result1 &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; result2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__address_html_aa734f67f653b6979f7c359ead8202fdf"><div class="ttname"><a href="classipaddress_1_1ip__address.html#aa734f67f653b6979f7c359ead8202fdf">ipaddress::ip_address::parse</a></div><div class="ttdeci">static consteval inline ip_address parse() noexcept</div><div class="ttdoc">Static method template to parse an IP address from a fixed string at compile time.</div><div class="ttdef"><b>Definition</b> ip-any-address.hpp:489</div></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_a1680eeca5814f1e58ee81fc3de5d20df"><div class="ttname"><a href="#a1680eeca5814f1e58ee81fc3de5d20df">ipaddress::ip_network::parse</a></div><div class="ttdeci">static consteval inline ip_network parse() noexcept</div><div class="ttdoc">Parses a network address and prefix from a fixed string at compile time.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:766</div></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_a947263a137b931017d2c3b1012d7d831"><div class="ttname"><a href="#a947263a137b931017d2c3b1012d7d831">ipaddress::ip_network::contains</a></div><div class="ttdeci">constexpr inline bool contains(const ip_address &amp;address) const noexcept</div><div class="ttdoc">Checks if the given IP address is contained within this network.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:324</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the address is part of the network, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab4ddaec67a3a14e19371900f207d753d" name="ab4ddaec67a3a14e19371900f207d753d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ddaec67a3a14e19371900f207d753d">&#9670;&#160;</a></span>overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this network overlaps with another network. </p>
<p>This method checks if there is any overlap between the network represented by this ip network object and another network, meaning if any part of one network lies within the other.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;1.2.3.0/24&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;1.2.3.0/30&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#ab4ddaec67a3a14e19371900f207d753d">overlaps</a> = a.overlaps(b);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; <a class="code hl_function" href="#ab4ddaec67a3a14e19371900f207d753d">overlaps</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_ab4ddaec67a3a14e19371900f207d753d"><div class="ttname"><a href="#ab4ddaec67a3a14e19371900f207d753d">ipaddress::ip_network::overlaps</a></div><div class="ttdeci">constexpr inline bool overlaps(const ip_network &amp;other) const noexcept</div><div class="ttdoc">Determines if this network overlaps with another network.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:351</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is an overlap, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3388c3cd2b15e9d6800eeae91f4d0797" name="a3388c3cd2b15e9d6800eeae91f4d0797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3388c3cd2b15e9d6800eeae91f4d0797">&#9670;&#160;</a></span>subnet_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool subnet_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this network is a subnet of another network. </p>
<p>This method verifies if the network represented by this ip network object is a subnet of the provided network, meaning if this network is entirely contained within the other network.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.168.1.0/24&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.168.1.128/30&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#a3388c3cd2b15e9d6800eeae91f4d0797">subnet_of</a> = a.subnet_of(b);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; <a class="code hl_function" href="#a3388c3cd2b15e9d6800eeae91f4d0797">subnet_of</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_a3388c3cd2b15e9d6800eeae91f4d0797"><div class="ttname"><a href="#a3388c3cd2b15e9d6800eeae91f4d0797">ipaddress::ip_network::subnet_of</a></div><div class="ttdeci">constexpr inline bool subnet_of(const ip_network &amp;other) const noexcept</div><div class="ttdoc">Checks if this network is a subnet of another network.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:378</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this network is a subnet of the other network, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9a37309e62e498d68811df908904c328" name="a9a37309e62e498d68811df908904c328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a37309e62e498d68811df908904c328">&#9670;&#160;</a></span>supernet_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool supernet_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this network is a supernet of another network. </p>
<p>This method determines if the network represented by this ip network object is a supernet of the provided network, meaning if the other network is entirely contained within this network.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.168.1.0/24&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.168.1.128/30&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#a9a37309e62e498d68811df908904c328">supernet_of</a> = a.supernet_of(b);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; <a class="code hl_function" href="#a9a37309e62e498d68811df908904c328">supernet_of</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_a9a37309e62e498d68811df908904c328"><div class="ttname"><a href="#a9a37309e62e498d68811df908904c328">ipaddress::ip_network::supernet_of</a></div><div class="ttdeci">constexpr inline bool supernet_of(const ip_network &amp;other) const noexcept</div><div class="ttdoc">Checks if this network is a supernet of another network.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:405</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this network is a supernet of the other network, false otherwise. </dd></dl>

</div>
</div>
<a id="ab1288f457a02658d5bc47c121b7a2d6b" name="ab1288f457a02658d5bc47c121b7a2d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1288f457a02658d5bc47c121b7a2d6b">&#9670;&#160;</a></span>hosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1hosts__any__sequence.html">hosts_any_sequence</a> hosts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a sequence of host addresses in the network. </p>
<p>This method returns a sequence of host addresses within the network, excluding the network and broadcast addresses.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> hosts_sequence = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/29&quot;</span>).<a class="code hl_function" href="#ab1288f457a02658d5bc47c121b7a2d6b">hosts</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; addr : hosts_sequence) {</div>
<div class="line">   std::cout &lt;&lt; addr &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.1</span></div>
<div class="line"><span class="comment">// 192.0.2.2</span></div>
<div class="line"><span class="comment">// 192.0.2.3</span></div>
<div class="line"><span class="comment">// 192.0.2.4</span></div>
<div class="line"><span class="comment">// 192.0.2.5</span></div>
<div class="line"><span class="comment">// 192.0.2.6</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_ab1288f457a02658d5bc47c121b7a2d6b"><div class="ttname"><a href="#ab1288f457a02658d5bc47c121b7a2d6b">ipaddress::ip_network::hosts</a></div><div class="ttdeci">constexpr inline hosts_any_sequence hosts() const noexcept</div><div class="ttdoc">Retrieves a sequence of host addresses in the network.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:448</div></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>A <code>hosts_sequence</code> object representing the sequence of host addresses. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Ipv4</td><td>For ipv4 all the IP addresses that belong to the network, except the network address itself and the network broadcast address. For networks with a mask length of 31, the network address and network broadcast address are also included in the result. Networks with a mask of 32 will return a list containing the single host address. </td></tr>
    <tr><td class="paramname">Ipv6</td><td>For ipv6 all the IP addresses that belong to the network, except the Subnet-Router anycast address. For networks with a mask length of 127, the Subnet-Router anycast address is also included in the result. Networks with a mask of 128 will return a list containing the single host address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Please note that with IPv6, the number of addresses can be so large that iterating through them all may be practically impossible. Therefore, use the <a class="el" href="#ab1288f457a02658d5bc47c121b7a2d6b" title="Retrieves a sequence of host addresses in the network.">hosts()</a> method cautiously to avoid endlessly retrieving addresses. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code>hosts_sequence</code> uses lazy evaluation to iterate addresses. </dd></dl>

</div>
</div>
<a id="a7607994f130363d19b51aa5aa661c24a" name="a7607994f130363d19b51aa5aa661c24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7607994f130363d19b51aa5aa661c24a">&#9670;&#160;</a></span>subnets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1subnets__any__sequence.html">subnets_any_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt; subnets </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen_diff</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of subnets from this network. </p>
<p>The subnets that join to make the current network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be increased by. new_prefix is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of <em>prefixlen_diff</em> and new_prefix must be set.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a> = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/24&quot;</span>).<a class="code hl_function" href="#a7607994f130363d19b51aa5aa661c24a">subnets</a>(2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>) {</div>
<div class="line">   std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.0/26</span></div>
<div class="line"><span class="comment">// 192.0.2.64/26</span></div>
<div class="line"><span class="comment">// 192.0.2.128/26</span></div>
<div class="line"><span class="comment">// 192.0.2.192/26</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html_a7607994f130363d19b51aa5aa661c24a"><div class="ttname"><a href="#a7607994f130363d19b51aa5aa661c24a">ipaddress::ip_network::subnets</a></div><div class="ttdeci">constexpr inline subnets_any_sequence&lt; ip_network &gt; subnets(size_t prefixlen_diff=1, optional&lt; size_t &gt; new_prefixlen=nullptr) const</div><div class="ttdoc">Generates a sequence of subnets from this network.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:485</div></div>
<div class="ttc" id="aclassipaddress_1_1subnets__sequence_html"><div class="ttname"><a href="classipaddress_1_1subnets__sequence.html">ipaddress::subnets_sequence</a></div><div class="ttdoc">A sequence container for subnet ranges within a network.</div><div class="ttdef"><b>Definition</b> ip-network-iterator.hpp:740</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen_diff</td><td>The difference in prefix length for the subnets. <em>Defaults to 1</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_prefixlen</td><td>An optional new prefix length for the subnets. If not specified, the prefix length is determined by adding <em>prefixlen_diff</em> to the current prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classipaddress_1_1subnets__any__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_any_sequence</a></code> object representing the sequence of subnets. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a></td><td>Raised if the operation cannot be performed due to invalid parameters or prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1subnets__any__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_any_sequence</a></code> uses lazy evaluation to iterate over the subnets. </dd></dl>

</div>
</div>
<a id="a1f48ce59958e8eee935eb1196edce2fa" name="a1f48ce59958e8eee935eb1196edce2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f48ce59958e8eee935eb1196edce2fa">&#9670;&#160;</a></span>subnets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1subnets__any__sequence.html">subnets_any_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt; subnets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen_diff</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of subnets from this network with error handling. </p>
<p>The subnets that join to make the current network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be increased by. new_prefix is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of <em>prefixlen_diff</em> and new_prefix must be set.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> err = <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c">error_code::NO_ERROR</a>;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a> = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/24&quot;</span>).<a class="code hl_function" href="#a7607994f130363d19b51aa5aa661c24a">subnets</a>(err, 2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (err == <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c">error_code::NO_ERROR</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>) {</div>
<div class="line">       std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.0/26</span></div>
<div class="line"><span class="comment">// 192.0.2.64/26</span></div>
<div class="line"><span class="comment">// 192.0.2.128/26</span></div>
<div class="line"><span class="comment">// 192.0.2.192/26</span></div>
<div class="ttc" id="anamespaceipaddress_html_a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c"><div class="ttname"><a href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c">ipaddress::error_code::NO_ERROR</a></div><div class="ttdeci">@ NO_ERROR</div><div class="ttdoc">Indicates the absence of any errors.</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during the operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen_diff</td><td>The difference in prefix length for the subnets. <em>Defaults to 1</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_prefixlen</td><td>An optional new prefix length for the subnets. If not specified, the prefix length is determined by adding <em>prefixlen_diff</em> to the current prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classipaddress_1_1subnets__any__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_any_sequence</a></code> object representing the sequence of subnets, or an empty sequence if an error occurs. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1subnets__any__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_any_sequence</a></code> uses lazy evaluation to iterate over the subnets. </dd></dl>

</div>
</div>
<a id="adfed79e42747c3a087a1e7e338895a4a" name="adfed79e42747c3a087a1e7e338895a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfed79e42747c3a087a1e7e338895a4a">&#9670;&#160;</a></span>address_exclude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt; address_exclude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the network definitions resulting from removing the given network from this one. </p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.1/32&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> exclude_sequence = a.address_exclude(b);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : exclude_sequence) {</div>
<div class="line">   std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.8/29</span></div>
<div class="line"><span class="comment">// 192.0.2.4/30</span></div>
<div class="line"><span class="comment">// 192.0.2.2/31</span></div>
<div class="line"><span class="comment">// 192.0.2.0/32</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other network to exclude from this network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> object representing the remaining address ranges. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a></td><td>Raise if network is not completely contained in this network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> uses lazy evaluation to iterate networks. </dd></dl>

</div>
</div>
<a id="ad33b915d7fbd38b2811c3da45e2cd040" name="ad33b915d7fbd38b2811c3da45e2cd040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33b915d7fbd38b2811c3da45e2cd040">&#9670;&#160;</a></span>address_exclude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &gt; address_exclude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the network definitions resulting from removing the given network from this one, with error handling. </p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1680eeca5814f1e58ee81fc3de5d20df">ip_network::parse</a>(<span class="stringliteral">&quot;192.0.2.1/32&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> err = <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c">error_code::NO_ERROR</a>;</div>
<div class="line"><span class="keyword">auto</span> exclude_sequence = a.address_exclude(b, err);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (err == <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c">error_code::NO_ERROR</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : exclude_sequence) {</div>
<div class="line">       std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.8/29</span></div>
<div class="line"><span class="comment">// 192.0.2.4/30</span></div>
<div class="line"><span class="comment">// 192.0.2.2/31</span></div>
<div class="line"><span class="comment">// 192.0.2.0/32</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other network to exclude from this network. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> object representing the remaining address ranges, or an empty sequence if an error occurs. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> uses lazy evaluation to iterate networks. </dd></dl>

</div>
</div>
<a id="ae063b5c983c82062126fd59b96ed65dc" name="ae063b5c983c82062126fd59b96ed65dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae063b5c983c82062126fd59b96ed65dc">&#9670;&#160;</a></span>v4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; <a class="el" href="namespaceipaddress.html#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> &gt; v4 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the IPv4 network. </p>
<p>If the IP network is an IPv4 network, this function returns the IPv4 network.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional containing the IPv4 network, or an empty optional if the IP network is not IPv4. </dd></dl>

</div>
</div>
<a id="acb478d3edc31e5fec89d6a0de9145beb" name="acb478d3edc31e5fec89d6a0de9145beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb478d3edc31e5fec89d6a0de9145beb">&#9670;&#160;</a></span>v6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; <a class="el" href="namespaceipaddress.html#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> &gt; v6 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the IPv6 network. </p>
<p>If the IP network is an IPv6 network, this function returns the IPv6 network.</p>
<dl class="section return"><dt>Returns</dt><dd>An optional containing the IPv6 network, or an empty optional if the IP network is not IPv6. </dd></dl>

</div>
</div>
<a id="a7eb26d7695f6dbc1276ade0dbb7d3453" name="a7eb26d7695f6dbc1276ade0dbb7d3453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb26d7695f6dbc1276ade0dbb7d3453">&#9670;&#160;</a></span>from_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> from_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an ip network object from a given IP address and prefix length. </p>
<p>This static method constructs an ip network object representing the network that includes the given IP address, with the specified prefix length. If 'strict' is true, the address is validated against the netmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to use for creating the network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen</td><td>The prefix length for the network's netmask. <em>Defaults to the maximum prefix length</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Whether to validate the address against the netmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object representing the network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>May throw an exception if the address does not conform to the netmask when <em>strict</em> is <code>true</code>. </dd></dl>

</div>
</div>
<a id="a2c8ea0801c6190f7d0ddf8f71664e588" name="a2c8ea0801c6190f7d0ddf8f71664e588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8ea0801c6190f7d0ddf8f71664e588">&#9670;&#160;</a></span>from_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> from_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an ip network object from a given IP address and prefix length, with error handling. </p>
<p>Similar to the from_address method above, but this version allows for error handling without exceptions. It populates the provided error_code object instead of throwing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to use for creating the network. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen</td><td>The prefix length for the network's netmask. Defaults to the maximum prefix length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Whether to validate the address against the netmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object representing the network, or an object in an error state if an error occurs. </dd></dl>

</div>
</div>
<a id="ae5c89e293118ded7cd33e0f0395cbd62" name="ae5c89e293118ded7cd33e0f0395cbd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c89e293118ded7cd33e0f0395cbd62">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eb">format</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672">format::compressed</a></span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the network to a string representation. </p>
<p>This method returns a string representation of the network, combining the network address and the prefix length, formatted according to the specified format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The format to use for the string representation. <em>Defaults to <a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672" title="Compressed format with maximal omission of segments or octets.">format::compressed</a></em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the network. </dd></dl>

</div>
</div>
<a id="a00b1372b4325fb657c316348be6a8139" name="a00b1372b4325fb657c316348be6a8139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b1372b4325fb657c316348be6a8139">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>net</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this network with another network. </p>
<p>This method exchanges the network address, netmask, and prefix length with those of another ip network object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">net</td><td>The other <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object to swap contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1680eeca5814f1e58ee81fc3de5d20df" name="a1680eeca5814f1e58ee81fc3de5d20df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1680eeca5814f1e58ee81fc3de5d20df">&#9670;&#160;</a></span>parse() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString, bool Strict = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static consteval inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a fixed string at compile time. </p>
<p>This template function allows for the compile-time parsing of an IP network address and prefix length from a fixed string. It is enabled only when non-type template parameters are supported by the compiler.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A string literal representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramname">Strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A consteval ip network object representing the parsed network. </dd></dl>

</div>
</div>
<a id="a0126c09bbd350d0cca794727ab2ac4eb" name="a0126c09bbd350d0cca794727ab2ac4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0126c09bbd350d0cca794727ab2ac4eb">&#9670;&#160;</a></span>parse() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a string view. </p>
<p>This function parses an IP network address and prefix length from a string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="acda48a8a649cc76ea319229dfa3671d8" name="acda48a8a649cc76ea319229dfa3671d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda48a8a649cc76ea319229dfa3671d8">&#9670;&#160;</a></span>parse() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a wide string view. </p>
<p>This function parses an IP network address and prefix length from a wide string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The wide string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::wstring</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="ad7ff9fb93131df0190e1e749398c77c0" name="ad7ff9fb93131df0190e1e749398c77c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ff9fb93131df0190e1e749398c77c0">&#9670;&#160;</a></span>parse() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u8string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-8 string view. </p>
<p>This function parses an IP network address and prefix length from UTF-8 string view. It leverages the <code>char8_t</code> type introduced in C++20 to handle UTF-8 strings natively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A UTF-8 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++20 and later versions where <code>char8_t</code> is supported. </dd></dl>

</div>
</div>
<a id="a2915718e70c297a8b76394590e5c0999" name="a2915718e70c297a8b76394590e5c0999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2915718e70c297a8b76394590e5c0999">&#9670;&#160;</a></span>parse() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u16string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-16 string view. </p>
<p>This function parses an IP network address and prefix length from UTF-16 string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-16 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u16string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a96a16d08818536742cbc6db98aa5c37b" name="a96a16d08818536742cbc6db98aa5c37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a16d08818536742cbc6db98aa5c37b">&#9670;&#160;</a></span>parse() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u32string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-32 string view. </p>
<p>This function parses an IP network address and prefix length from UTF-32 string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-32 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u32string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a5404cb00599c2ee19e34546c192bc1a9" name="a5404cb00599c2ee19e34546c192bc1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5404cb00599c2ee19e34546c192bc1a9">&#9670;&#160;</a></span>parse() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a string view with error handling. </p>
<p>This function parses an IP network address and prefix length from a string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a3da72c9d5861a2d8f6792a9773170f23" name="a3da72c9d5861a2d8f6792a9773170f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da72c9d5861a2d8f6792a9773170f23">&#9670;&#160;</a></span>parse() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a wide string view with error handling. </p>
<p>This function parses an IP network address and prefix length from a wide string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The wide string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::wstring</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="ab1374f2493d333f77158cf5dfa0c1ce7" name="ab1374f2493d333f77158cf5dfa0c1ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1374f2493d333f77158cf5dfa0c1ce7">&#9670;&#160;</a></span>parse() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u8string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-8 string view with error handling. </p>
<p>This function parses an IP network address and prefix length from UTF-8 string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-8 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++20 and later versions where <code>char8_t</code> is supported. </dd></dl>

</div>
</div>
<a id="a1e6af4ee373a8b570edb52dd350baeb1" name="a1e6af4ee373a8b570edb52dd350baeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6af4ee373a8b570edb52dd350baeb1">&#9670;&#160;</a></span>parse() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u16string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-16 string view with error handling. </p>
<p>This function parses an IP network address and prefix length from UTF-16 string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-16 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u16string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a79a108ef4f69c7fd3285e9ef7460055c" name="a79a108ef4f69c7fd3285e9ef7460055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a108ef4f69c7fd3285e9ef7460055c">&#9670;&#160;</a></span>parse() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u32string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-32 string view with error handling. </p>
<p>This function parses an IP network address and prefix length from UTF-32 string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-32 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u32string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a9e6771535ee5da9f99aab7ea6c5470e1" name="a9e6771535ee5da9f99aab7ea6c5470e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6771535ee5da9f99aab7ea6c5470e1">&#9670;&#160;</a></span>parse() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>address</em>[N], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a character array. </p>
<p>This function parses an IP network address and prefix length from a character array of a specified size. Can check and get the result at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type of the array. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The character array representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>

</div>
</div>
<a id="a8dd094fe87a4508afca91262df55f82a" name="a8dd094fe87a4508afca91262df55f82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd094fe87a4508afca91262df55f82a">&#9670;&#160;</a></span>parse() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> parse </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>address</em>[N], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a character array and reports errors through an error code. </p>
<p>This function parses an IP network address and prefix length from a character array of a specified size and provides an error code if the parsing fails.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type of the array. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The character array representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>

</div>
</div>
<a id="a177c561d99ae9901e0d42d503cea43a3" name="a177c561d99ae9901e0d42d503cea43a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c561d99ae9901e0d42d503cea43a3">&#9670;&#160;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline operator std::string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the ip network object to a std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::string</code> representation of the ip network object. </dd></dl>

</div>
</div>
<a id="a4ef898a03a2ede8c01fed40c932351ef" name="a4ef898a03a2ede8c01fed40c932351ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef898a03a2ede8c01fed40c932351ef">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<p>Compares this ip network object to another for equality based on the network address and netmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both objects are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa9c14c5004c8c0ccfd33c7d7c4ba962d" name="aa9c14c5004c8c0ccfd33c7d7c4ba962d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c14c5004c8c0ccfd33c7d7c4ba962d">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator. </p>
<p>Compares this ip network object to another for inequality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both objects are not equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac614e54e8c4d7f1911c5f79e86a36acd" name="ac614e54e8c4d7f1911c5f79e86a36acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac614e54e8c4d7f1911c5f79e86a36acd">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than comparison operator. </p>
<p>Determines if this ip network object is less than another by comparing network addresses and netmasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is less than the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a52d7715958b91ca4482f21e1d60dc055" name="a52d7715958b91ca4482f21e1d60dc055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d7715958b91ca4482f21e1d60dc055">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than comparison operator. </p>
<p>Determines if this ip network object is greater than another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is greater than the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a31a53b855482d8c9ac7f94df4d06046d" name="a31a53b855482d8c9ac7f94df4d06046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a53b855482d8c9ac7f94df4d06046d">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal to comparison operator. </p>
<p>Determines if this ip network object is less than or equal to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is less than or equal to the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a01df7f12b3209c650d7391e7e8f94762" name="a01df7f12b3209c650d7391e7e8f94762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01df7f12b3209c650d7391e7e8f94762">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal to comparison operator. </p>
<p>Determines if this ip network object is greater than or equal to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is greater than or equal to the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ipaddress/<a class="el" href="ip-any-network_8hpp_source.html">ip-any-network.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceipaddress.html">ipaddress</a></li><li class="navelem"><a class="el" href="classipaddress_1_1ip__network.html">ip_network</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
