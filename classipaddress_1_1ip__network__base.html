<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="ipaddress" />
<meta property="og:image" content="https://vladimirshaleev.github.io/ipaddress/constexpr.png" />
<meta property="og:description" content="A library for working and manipulating IPv4/IPv6 addresses and networks in modern C++." />
<meta property="og:url" content="https://vladimirshaleev.github.io/ipaddress/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://vladimirshaleev.github.io/ipaddress/constexpr.png" />
<meta name="twitter:title" content="ipaddress" />
<meta name="twitter:description" content="A library for working and manipulating IPv4/IPv6 addresses and networks in modern C++." />
<!-- END twitter metadata -->
<title>ipaddress: ip_network_base&lt; Base &gt; Class Template Reference</title>
<link rel="icon" href="logo.svg" type="image/svg+xml" />
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<link rel="icon" sizes="16x16" href="favicon-16x16.png" type="image/png">
<link rel="icon" sizes="32x32" href="favicon-32x32.png" type="image/png">
<link rel="apple-touch-icon" sizes="57x57" href="apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
<link rel="mask-icon" color="#5f8893" href="safari-pinned-tab.svg">
<meta name="msapplication-TileColor" content="#4a9cf8">
<meta name="msapplication-TileImage" content="mstile-144x144.png">
<meta name="msapplication-square70x70logo" content="mstile-70x70.png">
<meta name="msapplication-square150x150logo" content="mstile-150x150.png">
<meta name="msapplication-wide310x150logo" content="mstile-310x310.png">
<meta name="msapplication-square310x310logo" content="mstile-310x150.png">
<meta name="msapplication-config" content="browserconfig.xml">
<meta name="application-name" content="ipaddress">
<link rel="manifest" href="site.webmanifest">
<meta name="theme-color" content="#ffffff">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/VladimirShaleev/ipaddress" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
  <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
  <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ipaddress<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classipaddress_1_1ip__network__base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classipaddress_1_1ip__network__base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ip_network_base&lt; Base &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Template base class for representing a network of IP addresses.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ip-network-base_8hpp_source.html">ip-network-base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ip_network_base&lt; Base &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipaddress_1_1ip__network__base__inherit__graph.svg" width="440" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa3eb26f878db2cbaaa0541725fbf87f6" id="r_aa3eb26f878db2cbaaa0541725fbf87f6"><td class="memItemLeft" align="right" valign="top"><a id="aa3eb26f878db2cbaaa0541725fbf87f6" name="aa3eb26f878db2cbaaa0541725fbf87f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ip_address_type</b> = typename Base::ip_address_type</td></tr>
<tr class="memdesc:aa3eb26f878db2cbaaa0541725fbf87f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IP address type used by the network. <br /></td></tr>
<tr class="separator:aa3eb26f878db2cbaaa0541725fbf87f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac038a48d937a09ee9bd737557d66fbed" id="r_ac038a48d937a09ee9bd737557d66fbed"><td class="memItemLeft" align="right" valign="top"><a id="ac038a48d937a09ee9bd737557d66fbed" name="ac038a48d937a09ee9bd737557d66fbed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>uint_type</b> = typename ip_address_type::uint_type</td></tr>
<tr class="memdesc:ac038a48d937a09ee9bd737557d66fbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type used for the underlying IP address representation. <br /></td></tr>
<tr class="separator:ac038a48d937a09ee9bd737557d66fbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64052be6fc86cf1b945a6715a696dd5e" id="r_a64052be6fc86cf1b945a6715a696dd5e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64052be6fc86cf1b945a6715a696dd5e">ip_network_base</a> () noexcept</td></tr>
<tr class="memdesc:a64052be6fc86cf1b945a6715a696dd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new IP network base object.  <br /></td></tr>
<tr class="separator:a64052be6fc86cf1b945a6715a696dd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a23ecb2b274686aea259a350dc659e" id="r_a39a23ecb2b274686aea259a350dc659e"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39a23ecb2b274686aea259a350dc659e">contains</a> (const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;address) const noexcept</td></tr>
<tr class="memdesc:a39a23ecb2b274686aea259a350dc659e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given IP address is contained within this network.  <br /></td></tr>
<tr class="separator:a39a23ecb2b274686aea259a350dc659e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643558d92fd45671de7c87c1bc5b72e6" id="r_a643558d92fd45671de7c87c1bc5b72e6"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a643558d92fd45671de7c87c1bc5b72e6">overlaps</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a643558d92fd45671de7c87c1bc5b72e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this network overlaps with another network.  <br /></td></tr>
<tr class="separator:a643558d92fd45671de7c87c1bc5b72e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba001004b11a6378bea4fd75a72b79d" id="r_aeba001004b11a6378bea4fd75a72b79d"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeba001004b11a6378bea4fd75a72b79d">subnet_of</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:aeba001004b11a6378bea4fd75a72b79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this network is a subnet of another network.  <br /></td></tr>
<tr class="separator:aeba001004b11a6378bea4fd75a72b79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d0612a1a09c80958b4667496e38e29" id="r_aa9d0612a1a09c80958b4667496e38e29"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9d0612a1a09c80958b4667496e38e29">supernet_of</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:aa9d0612a1a09c80958b4667496e38e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this network is a supernet of another network.  <br /></td></tr>
<tr class="separator:aa9d0612a1a09c80958b4667496e38e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c89e293118ded7cd33e0f0395cbd62" id="r_ae5c89e293118ded7cd33e0f0395cbd62"><td class="memItemLeft" align="right" valign="top">inline std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5c89e293118ded7cd33e0f0395cbd62">to_string</a> (<a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eb">format</a> fmt=<a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672">format::compressed</a>) const</td></tr>
<tr class="memdesc:ae5c89e293118ded7cd33e0f0395cbd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the network to a string representation.  <br /></td></tr>
<tr class="separator:ae5c89e293118ded7cd33e0f0395cbd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3e71912b9d18f2568be16f50179c2b" id="r_adc3e71912b9d18f2568be16f50179c2b"><td class="memItemLeft" align="right" valign="top">constexpr inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc3e71912b9d18f2568be16f50179c2b">swap</a> (<a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;network) noexcept</td></tr>
<tr class="memdesc:adc3e71912b9d18f2568be16f50179c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this network with another network.  <br /></td></tr>
<tr class="separator:adc3e71912b9d18f2568be16f50179c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea6c821fe871e802647d69810a470d" id="r_ab4ea6c821fe871e802647d69810a470d"><td class="memItemLeft" align="right" valign="top">constexpr inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ea6c821fe871e802647d69810a470d">hash</a> () const noexcept</td></tr>
<tr class="memdesc:ab4ea6c821fe871e802647d69810a470d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash value for the network.  <br /></td></tr>
<tr class="separator:ab4ea6c821fe871e802647d69810a470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf7228c6640584542c7f113cda4c73b" id="r_aedf7228c6640584542c7f113cda4c73b"><td class="memItemLeft" align="right" valign="top">constexpr inline const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedf7228c6640584542c7f113cda4c73b">network_address</a> () const noexcept</td></tr>
<tr class="memdesc:aedf7228c6640584542c7f113cda4c73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the network address of this network.  <br /></td></tr>
<tr class="separator:aedf7228c6640584542c7f113cda4c73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce945b11159159d22168fe75fca109" id="r_a48ce945b11159159d22168fe75fca109"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ce945b11159159d22168fe75fca109">broadcast_address</a> () const noexcept</td></tr>
<tr class="memdesc:a48ce945b11159159d22168fe75fca109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the broadcast address of this network.  <br /></td></tr>
<tr class="separator:a48ce945b11159159d22168fe75fca109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7814fc154e2054cc8caea2f97996bc9a" id="r_a7814fc154e2054cc8caea2f97996bc9a"><td class="memItemLeft" align="right" valign="top">constexpr inline const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7814fc154e2054cc8caea2f97996bc9a">netmask</a> () const noexcept</td></tr>
<tr class="memdesc:a7814fc154e2054cc8caea2f97996bc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the netmask of this network.  <br /></td></tr>
<tr class="separator:a7814fc154e2054cc8caea2f97996bc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34efffb7567ae9f6528aeef9fe76a469" id="r_a34efffb7567ae9f6528aeef9fe76a469"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34efffb7567ae9f6528aeef9fe76a469">hostmask</a> () const noexcept</td></tr>
<tr class="memdesc:a34efffb7567ae9f6528aeef9fe76a469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hostmask of this network.  <br /></td></tr>
<tr class="separator:a34efffb7567ae9f6528aeef9fe76a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd6479c08209e28e1320a72f708686" id="r_ad4cd6479c08209e28e1320a72f708686"><td class="memItemLeft" align="right" valign="top">constexpr inline size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4cd6479c08209e28e1320a72f708686">prefixlen</a> () const noexcept</td></tr>
<tr class="memdesc:ad4cd6479c08209e28e1320a72f708686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the prefix length of this network.  <br /></td></tr>
<tr class="separator:ad4cd6479c08209e28e1320a72f708686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d509ad04e4e88eea0d5f21037632ca" id="r_a28d509ad04e4e88eea0d5f21037632ca"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28d509ad04e4e88eea0d5f21037632ca">is_multicast</a> () const noexcept</td></tr>
<tr class="memdesc:a28d509ad04e4e88eea0d5f21037632ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a multicast network.  <br /></td></tr>
<tr class="separator:a28d509ad04e4e88eea0d5f21037632ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c5dfb1a24f7a177abe288df2fe1b4b" id="r_a30c5dfb1a24f7a177abe288df2fe1b4b"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30c5dfb1a24f7a177abe288df2fe1b4b">is_private</a> () const noexcept</td></tr>
<tr class="memdesc:a30c5dfb1a24f7a177abe288df2fe1b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a private network.  <br /></td></tr>
<tr class="separator:a30c5dfb1a24f7a177abe288df2fe1b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0a20a93632cde3137e0ddd2b51e4f5" id="r_a9c0a20a93632cde3137e0ddd2b51e4f5"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c0a20a93632cde3137e0ddd2b51e4f5">is_global</a> () const noexcept</td></tr>
<tr class="memdesc:a9c0a20a93632cde3137e0ddd2b51e4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a global network.  <br /></td></tr>
<tr class="separator:a9c0a20a93632cde3137e0ddd2b51e4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4087941a260e1e8471dcaf9aa900c94d" id="r_a4087941a260e1e8471dcaf9aa900c94d"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4087941a260e1e8471dcaf9aa900c94d">is_reserved</a> () const noexcept</td></tr>
<tr class="memdesc:a4087941a260e1e8471dcaf9aa900c94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a reserved network.  <br /></td></tr>
<tr class="separator:a4087941a260e1e8471dcaf9aa900c94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e93e8e8ea4eebf9ae51e6d1bfefaf" id="r_ae32e93e8e8ea4eebf9ae51e6d1bfefaf"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae32e93e8e8ea4eebf9ae51e6d1bfefaf">is_loopback</a> () const noexcept</td></tr>
<tr class="memdesc:ae32e93e8e8ea4eebf9ae51e6d1bfefaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a loopback network.  <br /></td></tr>
<tr class="separator:ae32e93e8e8ea4eebf9ae51e6d1bfefaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48625896416a27deb6f4b131c4dbffbd" id="r_a48625896416a27deb6f4b131c4dbffbd"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48625896416a27deb6f4b131c4dbffbd">is_link_local</a> () const noexcept</td></tr>
<tr class="memdesc:a48625896416a27deb6f4b131c4dbffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is a link-local network.  <br /></td></tr>
<tr class="separator:a48625896416a27deb6f4b131c4dbffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfed15a9f11a663033a52142e71bc26" id="r_a8bfed15a9f11a663033a52142e71bc26"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bfed15a9f11a663033a52142e71bc26">is_unspecified</a> () const noexcept</td></tr>
<tr class="memdesc:a8bfed15a9f11a663033a52142e71bc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the network is an unspecified network.  <br /></td></tr>
<tr class="separator:a8bfed15a9f11a663033a52142e71bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ba25a33fe7de07c4fc1437697fc685" id="r_a60ba25a33fe7de07c4fc1437697fc685"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="#ac038a48d937a09ee9bd737557d66fbed">uint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60ba25a33fe7de07c4fc1437697fc685">addresses_count</a> () const noexcept</td></tr>
<tr class="memdesc:a60ba25a33fe7de07c4fc1437697fc685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total number of addresses in the network.  <br /></td></tr>
<tr class="separator:a60ba25a33fe7de07c4fc1437697fc685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c19443fa46e2546940326bbc2498947" id="r_a5c19443fa46e2546940326bbc2498947"><td class="memItemLeft" align="right" valign="top">constexpr inline hosts_sequence&lt; <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c19443fa46e2546940326bbc2498947">hosts</a> () const noexcept</td></tr>
<tr class="memdesc:a5c19443fa46e2546940326bbc2498947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a sequence of host addresses in the network.  <br /></td></tr>
<tr class="separator:a5c19443fa46e2546940326bbc2498947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313860fe97d2b9d69424a19eccfd1e19" id="r_a313860fe97d2b9d69424a19eccfd1e19"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a313860fe97d2b9d69424a19eccfd1e19">address_exclude</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;other) const</td></tr>
<tr class="memdesc:a313860fe97d2b9d69424a19eccfd1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the network definitions resulting from removing the given network from this one.  <br /></td></tr>
<tr class="separator:a313860fe97d2b9d69424a19eccfd1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6971f8b114c32d88fece634544858e1" id="r_af6971f8b114c32d88fece634544858e1"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6971f8b114c32d88fece634544858e1">address_exclude</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;other, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code) const noexcept</td></tr>
<tr class="memdesc:af6971f8b114c32d88fece634544858e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the network definitions resulting from removing the given network from this one, with error handling.  <br /></td></tr>
<tr class="separator:af6971f8b114c32d88fece634544858e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaaf38fa1199c9b5a4831bbde619ac4" id="r_a6aaaf38fa1199c9b5a4831bbde619ac4"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aaaf38fa1199c9b5a4831bbde619ac4">subnets</a> (size_t prefixlen_diff=1, <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt; new_prefixlen=nullptr) const</td></tr>
<tr class="memdesc:a6aaaf38fa1199c9b5a4831bbde619ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of subnets from this network.  <br /></td></tr>
<tr class="separator:a6aaaf38fa1199c9b5a4831bbde619ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87caa83096cee9c1f1f4463d5fa9e676" id="r_a87caa83096cee9c1f1f4463d5fa9e676"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87caa83096cee9c1f1f4463d5fa9e676">subnets</a> (<a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, size_t prefixlen_diff=1, <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt; new_prefixlen=nullptr) const noexcept</td></tr>
<tr class="memdesc:a87caa83096cee9c1f1f4463d5fa9e676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of subnets from this network with error handling.  <br /></td></tr>
<tr class="separator:a87caa83096cee9c1f1f4463d5fa9e676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d5d205e66991dde943eaf77e8671ad" id="r_a44d5d205e66991dde943eaf77e8671ad"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a> (size_t prefixlen_diff=1, <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt; new_prefixlen=nullptr) const</td></tr>
<tr class="memdesc:a44d5d205e66991dde943eaf77e8671ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a supernet from this network.  <br /></td></tr>
<tr class="separator:a44d5d205e66991dde943eaf77e8671ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa840d739050d32deed4571088353c87" id="r_afa840d739050d32deed4571088353c87"><td class="memItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa840d739050d32deed4571088353c87">supernet</a> (<a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, size_t prefixlen_diff=1, <a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt; new_prefixlen=nullptr) const noexcept</td></tr>
<tr class="memdesc:afa840d739050d32deed4571088353c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a supernet from this network with error handling.  <br /></td></tr>
<tr class="separator:afa840d739050d32deed4571088353c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3888dcd59dd5acd1ca5b9bee4c2e252a" id="r_a3888dcd59dd5acd1ca5b9bee4c2e252a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3888dcd59dd5acd1ca5b9bee4c2e252a">operator std::string</a> () const</td></tr>
<tr class="memdesc:a3888dcd59dd5acd1ca5b9bee4c2e252a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the ip network object to a std::string.  <br /></td></tr>
<tr class="separator:a3888dcd59dd5acd1ca5b9bee4c2e252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4f7eddba8b6535362a53fc55be74f4" id="r_a1c4f7eddba8b6535362a53fc55be74f4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c4f7eddba8b6535362a53fc55be74f4">operator==</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a1c4f7eddba8b6535362a53fc55be74f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <br /></td></tr>
<tr class="separator:a1c4f7eddba8b6535362a53fc55be74f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3131fe1d0ba16911a82b14b8eaf252b" id="r_ab3131fe1d0ba16911a82b14b8eaf252b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3131fe1d0ba16911a82b14b8eaf252b">operator!=</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ab3131fe1d0ba16911a82b14b8eaf252b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator.  <br /></td></tr>
<tr class="separator:ab3131fe1d0ba16911a82b14b8eaf252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b76868bfcd0b21168ea8557716a923a" id="r_a8b76868bfcd0b21168ea8557716a923a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b76868bfcd0b21168ea8557716a923a">operator&lt;</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a8b76868bfcd0b21168ea8557716a923a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than comparison operator.  <br /></td></tr>
<tr class="separator:a8b76868bfcd0b21168ea8557716a923a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac069d39bdeaa1f5c5df412787b01360c" id="r_ac069d39bdeaa1f5c5df412787b01360c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac069d39bdeaa1f5c5df412787b01360c">operator&gt;</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ac069d39bdeaa1f5c5df412787b01360c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than comparison operator.  <br /></td></tr>
<tr class="separator:ac069d39bdeaa1f5c5df412787b01360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354e42ec52dff3847595b95c80ba4f5a" id="r_a354e42ec52dff3847595b95c80ba4f5a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a354e42ec52dff3847595b95c80ba4f5a">operator&lt;=</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a354e42ec52dff3847595b95c80ba4f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to comparison operator.  <br /></td></tr>
<tr class="separator:a354e42ec52dff3847595b95c80ba4f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26213010ba81739e1496a1a7c4f03a7e" id="r_a26213010ba81739e1496a1a7c4f03a7e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26213010ba81739e1496a1a7c4f03a7e">operator&gt;=</a> (const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a26213010ba81739e1496a1a7c4f03a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to comparison operator.  <br /></td></tr>
<tr class="separator:a26213010ba81739e1496a1a7c4f03a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1ff563ad415ed4e9179472b3ec80caee" id="r_a1ff563ad415ed4e9179472b3ec80caee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString, bool Strict = true&gt; </td></tr>
<tr class="memitem:a1ff563ad415ed4e9179472b3ec80caee"><td class="memTemplItemLeft" align="right" valign="top">static consteval <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ff563ad415ed4e9179472b3ec80caee">parse</a> () noexcept</td></tr>
<tr class="memdesc:a1ff563ad415ed4e9179472b3ec80caee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a fixed string at compile time.  <br /></td></tr>
<tr class="separator:a1ff563ad415ed4e9179472b3ec80caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2610e8afa74c34e6a598afeeb236479" id="r_ad2610e8afa74c34e6a598afeeb236479"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2610e8afa74c34e6a598afeeb236479">parse</a> (std::string_view address, bool strict=true)</td></tr>
<tr class="memdesc:ad2610e8afa74c34e6a598afeeb236479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a string view.  <br /></td></tr>
<tr class="separator:ad2610e8afa74c34e6a598afeeb236479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8295e6cb2e92a042a3f3e5cea0325" id="r_ac8b8295e6cb2e92a042a3f3e5cea0325"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8b8295e6cb2e92a042a3f3e5cea0325">parse</a> (std::wstring_view address, bool strict=true)</td></tr>
<tr class="memdesc:ac8b8295e6cb2e92a042a3f3e5cea0325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a wide string view.  <br /></td></tr>
<tr class="separator:ac8b8295e6cb2e92a042a3f3e5cea0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc8233a6bf732414d5b9824fa63b18c" id="r_aedc8233a6bf732414d5b9824fa63b18c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc8233a6bf732414d5b9824fa63b18c">parse</a> (std::u8string_view address, bool strict=true)</td></tr>
<tr class="memdesc:aedc8233a6bf732414d5b9824fa63b18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-8 string view.  <br /></td></tr>
<tr class="separator:aedc8233a6bf732414d5b9824fa63b18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1953c21b16f7633b49cfcbee261c84b2" id="r_a1953c21b16f7633b49cfcbee261c84b2"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1953c21b16f7633b49cfcbee261c84b2">parse</a> (std::u16string_view address, bool strict=true)</td></tr>
<tr class="memdesc:a1953c21b16f7633b49cfcbee261c84b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-16 string view.  <br /></td></tr>
<tr class="separator:a1953c21b16f7633b49cfcbee261c84b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cbfd9fe196bdadb846df31e04bc6eb" id="r_ae5cbfd9fe196bdadb846df31e04bc6eb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5cbfd9fe196bdadb846df31e04bc6eb">parse</a> (std::u32string_view address, bool strict=true)</td></tr>
<tr class="memdesc:ae5cbfd9fe196bdadb846df31e04bc6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-32 string view.  <br /></td></tr>
<tr class="separator:ae5cbfd9fe196bdadb846df31e04bc6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec42a32b71715a22dbc870986394d9d" id="r_aaec42a32b71715a22dbc870986394d9d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec42a32b71715a22dbc870986394d9d">parse</a> (std::string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:aaec42a32b71715a22dbc870986394d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a string view with error handling.  <br /></td></tr>
<tr class="separator:aaec42a32b71715a22dbc870986394d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c75691653d30aaf9f23c65d7449f67f" id="r_a7c75691653d30aaf9f23c65d7449f67f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c75691653d30aaf9f23c65d7449f67f">parse</a> (std::wstring_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a7c75691653d30aaf9f23c65d7449f67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a wide string view with error handling.  <br /></td></tr>
<tr class="separator:a7c75691653d30aaf9f23c65d7449f67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce6545cce1c92b24325599b2c9fd905" id="r_a0ce6545cce1c92b24325599b2c9fd905"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ce6545cce1c92b24325599b2c9fd905">parse</a> (std::u8string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a0ce6545cce1c92b24325599b2c9fd905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-8 string view with error handling.  <br /></td></tr>
<tr class="separator:a0ce6545cce1c92b24325599b2c9fd905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3370bca9b5c926649d1175cf32b5041" id="r_ae3370bca9b5c926649d1175cf32b5041"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3370bca9b5c926649d1175cf32b5041">parse</a> (std::u16string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:ae3370bca9b5c926649d1175cf32b5041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-16 string view with error handling.  <br /></td></tr>
<tr class="separator:ae3370bca9b5c926649d1175cf32b5041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a69f8ed007fa5f9510205b60aac6bb" id="r_a55a69f8ed007fa5f9510205b60aac6bb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a69f8ed007fa5f9510205b60aac6bb">parse</a> (std::u32string_view address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a55a69f8ed007fa5f9510205b60aac6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from UTF-32 string view with error handling.  <br /></td></tr>
<tr class="separator:a55a69f8ed007fa5f9510205b60aac6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ed2b408412f1a67cb0943075c0c93e" id="r_a38ed2b408412f1a67cb0943075c0c93e"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a38ed2b408412f1a67cb0943075c0c93e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38ed2b408412f1a67cb0943075c0c93e">parse</a> (const T(&amp;address)[N], bool strict=true)</td></tr>
<tr class="memdesc:a38ed2b408412f1a67cb0943075c0c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a character array.  <br /></td></tr>
<tr class="separator:a38ed2b408412f1a67cb0943075c0c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af959e584b40f706c20e13ccc49ac842f" id="r_af959e584b40f706c20e13ccc49ac842f"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:af959e584b40f706c20e13ccc49ac842f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af959e584b40f706c20e13ccc49ac842f">parse</a> (const T(&amp;address)[N], <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, bool strict=true) noexcept</td></tr>
<tr class="memdesc:af959e584b40f706c20e13ccc49ac842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a network address and prefix from a character array and reports errors through an error code.  <br /></td></tr>
<tr class="separator:af959e584b40f706c20e13ccc49ac842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c18c8ab2c9ca72c4a21dd2b37ca229" id="r_ac1c18c8ab2c9ca72c4a21dd2b37ca229"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1c18c8ab2c9ca72c4a21dd2b37ca229">from_address</a> (const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;address, size_t <a class="el" href="#ad4cd6479c08209e28e1320a72f708686">prefixlen</a>=ip_address_type::max_prefixlen, bool strict=true)</td></tr>
<tr class="memdesc:ac1c18c8ab2c9ca72c4a21dd2b37ca229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ip network object from a given IP address and prefix length.  <br /></td></tr>
<tr class="separator:ac1c18c8ab2c9ca72c4a21dd2b37ca229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ead4c1611f1595743798836bb37f5" id="r_a517ead4c1611f1595743798836bb37f5"><td class="memItemLeft" align="right" valign="top">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a517ead4c1611f1595743798836bb37f5">from_address</a> (const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;address, <a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;code, size_t <a class="el" href="#ad4cd6479c08209e28e1320a72f708686">prefixlen</a>=ip_address_type::max_prefixlen, bool strict=true) noexcept</td></tr>
<tr class="memdesc:a517ead4c1611f1595743798836bb37f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ip network object from a given IP address and prefix length, with error handling.  <br /></td></tr>
<tr class="separator:a517ead4c1611f1595743798836bb37f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Base&gt;<br />
class ipaddress::ip_network_base&lt; Base &gt;</div><p>Template base class for representing a network of IP addresses. </p>
<p>This class provides the foundational elements for representing a network of IP addresses, offering methods to iterate over them and perform common network-related operations. It is designed to be flexible and work with any IP address type that conforms to a specific interface, making it suitable for both IPv4 and IPv6 networks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>The base class from which <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> inherits. Should be a type that represents an individual IP address. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64052be6fc86cf1b945a6715a696dd5e" name="a64052be6fc86cf1b945a6715a696dd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64052be6fc86cf1b945a6715a696dd5e">&#9670;&#160;</a></span>ip_network_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new IP network base object. </p>
<p>Initializes a new instance of the <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class with the maximum prefix length for the IP address type, effectively setting the network address to the default address and the netmask to the maximum value. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ff563ad415ed4e9179472b3ec80caee" name="a1ff563ad415ed4e9179472b3ec80caee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff563ad415ed4e9179472b3ec80caee">&#9670;&#160;</a></span>parse() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString, bool Strict = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static consteval <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a fixed string at compile time. </p>
<p>This template function allows for the compile-time parsing of an IP network address and prefix length from a fixed string. It is enabled only when non-type template parameters are supported by the compiler.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A string literal representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramname">Strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A consteval ip network object representing the parsed network. </dd></dl>

</div>
</div>
<a id="ad2610e8afa74c34e6a598afeeb236479" name="ad2610e8afa74c34e6a598afeeb236479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2610e8afa74c34e6a598afeeb236479">&#9670;&#160;</a></span>parse() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a string view. </p>
<p>This function parses an IP network address and prefix length from a string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="ac8b8295e6cb2e92a042a3f3e5cea0325" name="ac8b8295e6cb2e92a042a3f3e5cea0325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b8295e6cb2e92a042a3f3e5cea0325">&#9670;&#160;</a></span>parse() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a wide string view. </p>
<p>This function parses an IP network address and prefix length from a wide string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The wide string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::wstring</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="aedc8233a6bf732414d5b9824fa63b18c" name="aedc8233a6bf732414d5b9824fa63b18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc8233a6bf732414d5b9824fa63b18c">&#9670;&#160;</a></span>parse() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u8string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-8 string view. </p>
<p>This function parses an IP network address and prefix length from UTF-8 string view. It leverages the <code>char8_t</code> type introduced in C++20 to handle UTF-8 strings natively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A UTF-8 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++20 and later versions where <code>char8_t</code> is supported. </dd></dl>

</div>
</div>
<a id="a1953c21b16f7633b49cfcbee261c84b2" name="a1953c21b16f7633b49cfcbee261c84b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1953c21b16f7633b49cfcbee261c84b2">&#9670;&#160;</a></span>parse() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u16string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-16 string view. </p>
<p>This function parses an IP network address and prefix length from UTF-16 string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-16 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u16string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="ae5cbfd9fe196bdadb846df31e04bc6eb" name="ae5cbfd9fe196bdadb846df31e04bc6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cbfd9fe196bdadb846df31e04bc6eb">&#9670;&#160;</a></span>parse() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u32string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-32 string view. </p>
<p>This function parses an IP network address and prefix length from UTF-32 string view. It is available when the compiler supports C++17 or later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-32 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u32string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="aaec42a32b71715a22dbc870986394d9d" name="aaec42a32b71715a22dbc870986394d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec42a32b71715a22dbc870986394d9d">&#9670;&#160;</a></span>parse() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a string view with error handling. </p>
<p>This function parses an IP network address and prefix length from a string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a7c75691653d30aaf9f23c65d7449f67f" name="a7c75691653d30aaf9f23c65d7449f67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c75691653d30aaf9f23c65d7449f67f">&#9670;&#160;</a></span>parse() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::wstring_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a wide string view with error handling. </p>
<p>This function parses an IP network address and prefix length from a wide string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The wide string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::wstring</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a0ce6545cce1c92b24325599b2c9fd905" name="a0ce6545cce1c92b24325599b2c9fd905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce6545cce1c92b24325599b2c9fd905">&#9670;&#160;</a></span>parse() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u8string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-8 string view with error handling. </p>
<p>This function parses an IP network address and prefix length from UTF-8 string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-8 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++20 and later versions where <code>char8_t</code> is supported. </dd></dl>

</div>
</div>
<a id="ae3370bca9b5c926649d1175cf32b5041" name="ae3370bca9b5c926649d1175cf32b5041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3370bca9b5c926649d1175cf32b5041">&#9670;&#160;</a></span>parse() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u16string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-16 string view with error handling. </p>
<p>This function parses an IP network address and prefix length from UTF-16 string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-16 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u16string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a55a69f8ed007fa5f9510205b60aac6bb" name="a55a69f8ed007fa5f9510205b60aac6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a69f8ed007fa5f9510205b60aac6bb">&#9670;&#160;</a></span>parse() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">std::u32string_view</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from UTF-32 string view with error handling. </p>
<p>This function parses an IP network address and prefix length from UTF-32 string view, providing an error code for exception-free error handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The UTF-32 string view representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is available for C++17 and later versions. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For C++ versions prior to C++17, member functions with <code>std::u32string</code> and C-strings will be used instead. </dd></dl>

</div>
</div>
<a id="a38ed2b408412f1a67cb0943075c0c93e" name="a38ed2b408412f1a67cb0943075c0c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ed2b408412f1a67cb0943075c0c93e">&#9670;&#160;</a></span>parse() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>address</em>[N], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a character array. </p>
<p>This function parses an IP network address and prefix length from a character array of a specified size. Can check and get the result at compile time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type of the array. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The character array representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>

</div>
</div>
<a id="af959e584b40f706c20e13ccc49ac842f" name="af959e584b40f706c20e13ccc49ac842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af959e584b40f706c20e13ccc49ac842f">&#9670;&#160;</a></span>parse() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> parse </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>address</em>[N], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a network address and prefix from a character array and reports errors through an error code. </p>
<p>This function parses an IP network address and prefix length from a character array of a specified size and provides an error code if the parsing fails.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type of the array. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The character array representing the IP network in "address/prefix" format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during parsing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>A boolean flag indicating whether to perform strict validation of the address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the parsed network. </dd></dl>

</div>
</div>
<a id="ac1c18c8ab2c9ca72c4a21dd2b37ca229" name="ac1c18c8ab2c9ca72c4a21dd2b37ca229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c18c8ab2c9ca72c4a21dd2b37ca229">&#9670;&#160;</a></span>from_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> from_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">ip_address_type::max_prefixlen</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an ip network object from a given IP address and prefix length. </p>
<p>This static method constructs an ip network object representing the network that includes the given IP address, with the specified prefix length. If 'strict' is true, the address is validated against the netmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to use for creating the network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen</td><td>The prefix length for the network's netmask. <em>Defaults to the maximum prefix length</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Whether to validate the address against the netmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the network. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Exception caused by invalid input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>May throw an exception if the address does not conform to the netmask when <em>strict</em> is <code>true</code>. </dd></dl>

</div>
</div>
<a id="a517ead4c1611f1595743798836bb37f5" name="a517ead4c1611f1595743798836bb37f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517ead4c1611f1595743798836bb37f5">&#9670;&#160;</a></span>from_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a> from_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">ip_address_type::max_prefixlen</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an ip network object from a given IP address and prefix length, with error handling. </p>
<p>Similar to the from_address method above, but this version allows for error handling without exceptions. It populates the provided error_code object instead of throwing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to use for creating the network. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen</td><td>The prefix length for the network's netmask. Defaults to the maximum prefix length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Whether to validate the address against the netmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the network, or an object in an error state if an error occurs. </dd></dl>

</div>
</div>
<a id="a39a23ecb2b274686aea259a350dc659e" name="a39a23ecb2b274686aea259a350dc659e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a23ecb2b274686aea259a350dc659e">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given IP address is contained within this network. </p>
<p>This method determines whether the provided IP address is part of the network represented by this ip network object, based on the network address and netmask.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result1 = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>).<a class="code hl_function" href="#a39a23ecb2b274686aea259a350dc659e">contains</a>(<a class="code hl_function" href="classipaddress_1_1ip__address__base.html#a4b8772efdbcdd5c633c2aa31a97f3ed1">ipv4_address::parse</a>(<span class="stringliteral">&quot;192.0.2.6&quot;</span>));</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> result2 = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>).<a class="code hl_function" href="#a39a23ecb2b274686aea259a350dc659e">contains</a>(<a class="code hl_function" href="classipaddress_1_1ip__address__base.html#a4b8772efdbcdd5c633c2aa31a97f3ed1">ipv4_address::parse</a>(<span class="stringliteral">&quot;192.0.3.6&quot;</span>));</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; result1 &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; result2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__address__base_html_a4b8772efdbcdd5c633c2aa31a97f3ed1"><div class="ttname"><a href="classipaddress_1_1ip__address__base.html#a4b8772efdbcdd5c633c2aa31a97f3ed1">ipaddress::ip_address_base&lt; ipv4_address_base &gt;::parse</a></div><div class="ttdeci">static consteval inline ip_address_base&lt; ipv4_address_base &gt; parse() noexcept</div><div class="ttdoc">Static method template to parse an IP address from a fixed string at compile time.</div><div class="ttdef"><b>Definition</b> ip-address-base.hpp:123</div></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_a1ff563ad415ed4e9179472b3ec80caee"><div class="ttname"><a href="#a1ff563ad415ed4e9179472b3ec80caee">ipaddress::ip_network_base&lt; ipv4_network_base &gt;::parse</a></div><div class="ttdeci">static consteval ip_network_base parse() noexcept</div><div class="ttdoc">Parses a network address and prefix from a fixed string at compile time.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:65</div></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_a39a23ecb2b274686aea259a350dc659e"><div class="ttname"><a href="#a39a23ecb2b274686aea259a350dc659e">ipaddress::ip_network_base::contains</a></div><div class="ttdeci">constexpr inline bool contains(const ip_address_type &amp;address) const noexcept</div><div class="ttdoc">Checks if the given IP address is contained within this network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:488</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IP address to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the address is part of the network, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a643558d92fd45671de7c87c1bc5b72e6" name="a643558d92fd45671de7c87c1bc5b72e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643558d92fd45671de7c87c1bc5b72e6">&#9670;&#160;</a></span>overlaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this network overlaps with another network. </p>
<p>This method checks if there is any overlap between the network represented by this ip network object and another network, meaning if any part of one network lies within the other.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;1.2.3.0/24&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;1.2.3.0/30&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#a643558d92fd45671de7c87c1bc5b72e6">overlaps</a> = a.overlaps(b);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; <a class="code hl_function" href="#a643558d92fd45671de7c87c1bc5b72e6">overlaps</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_a643558d92fd45671de7c87c1bc5b72e6"><div class="ttname"><a href="#a643558d92fd45671de7c87c1bc5b72e6">ipaddress::ip_network_base::overlaps</a></div><div class="ttdeci">constexpr inline bool overlaps(const ip_network_base &amp;other) const noexcept</div><div class="ttdoc">Determines if this network overlaps with another network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:520</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is an overlap, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aeba001004b11a6378bea4fd75a72b79d" name="aeba001004b11a6378bea4fd75a72b79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba001004b11a6378bea4fd75a72b79d">&#9670;&#160;</a></span>subnet_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool subnet_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this network is a subnet of another network. </p>
<p>This method verifies if the network represented by this ip network object is a subnet of the provided network, meaning if this network is entirely contained within the other network.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.168.1.0/24&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.168.1.128/30&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#aeba001004b11a6378bea4fd75a72b79d">subnet_of</a> = a.subnet_of(b);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; <a class="code hl_function" href="#aeba001004b11a6378bea4fd75a72b79d">subnet_of</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// false</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_aeba001004b11a6378bea4fd75a72b79d"><div class="ttname"><a href="#aeba001004b11a6378bea4fd75a72b79d">ipaddress::ip_network_base::subnet_of</a></div><div class="ttdeci">constexpr inline bool subnet_of(const ip_network_base &amp;other) const noexcept</div><div class="ttdoc">Checks if this network is a subnet of another network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:543</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this network is a subnet of the other network, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa9d0612a1a09c80958b4667496e38e29" name="aa9d0612a1a09c80958b4667496e38e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d0612a1a09c80958b4667496e38e29">&#9670;&#160;</a></span>supernet_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool supernet_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this network is a supernet of another network. </p>
<p>This method determines if the network represented by this ip network object is a supernet of the provided network, meaning if the other network is entirely contained within this network.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.168.1.0/24&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.168.1.128/30&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#aa9d0612a1a09c80958b4667496e38e29">supernet_of</a> = a.supernet_of(b);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; <a class="code hl_function" href="#aa9d0612a1a09c80958b4667496e38e29">supernet_of</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// true</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_aa9d0612a1a09c80958b4667496e38e29"><div class="ttname"><a href="#aa9d0612a1a09c80958b4667496e38e29">ipaddress::ip_network_base::supernet_of</a></div><div class="ttdeci">constexpr inline bool supernet_of(const ip_network_base &amp;other) const noexcept</div><div class="ttdoc">Checks if this network is a supernet of another network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:566</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this network is a supernet of the other network, false otherwise. </dd></dl>

</div>
</div>
<a id="ae5c89e293118ded7cd33e0f0395cbd62" name="ae5c89e293118ded7cd33e0f0395cbd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c89e293118ded7cd33e0f0395cbd62">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eb">format</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672">format::compressed</a></span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the network to a string representation. </p>
<p>This method returns a string representation of the network, combining the network address and the prefix length, formatted according to the specified format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The format to use for the string representation. <em>Defaults to <a class="el" href="namespaceipaddress.html#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672" title="Compressed format with maximal omission of segments or octets.">format::compressed</a></em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the network. </dd></dl>

</div>
</div>
<a id="adc3e71912b9d18f2568be16f50179c2b" name="adc3e71912b9d18f2568be16f50179c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3e71912b9d18f2568be16f50179c2b">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>network</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this network with another network. </p>
<p>This method exchanges the network address, netmask, and prefix length with those of another ip network object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">network</td><td>The other ip network object to swap contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ea6c821fe871e802647d69810a470d" name="ab4ea6c821fe871e802647d69810a470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea6c821fe871e802647d69810a470d">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline size_t hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash value for the network. </p>
<p>This method computes a hash value for the network, which can be used for storing the object in hash-based containers.</p>
<dl class="section return"><dt>Returns</dt><dd>A size_t value representing the hash of the network. </dd></dl>

</div>
</div>
<a id="aedf7228c6640584542c7f113cda4c73b" name="aedf7228c6640584542c7f113cda4c73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf7228c6640584542c7f113cda4c73b">&#9670;&#160;</a></span>network_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp; network_address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the network address of this network. </p>
<p>This method returns the network address component of the ip network object.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the network address. </dd></dl>

</div>
</div>
<a id="a48ce945b11159159d22168fe75fca109" name="a48ce945b11159159d22168fe75fca109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce945b11159159d22168fe75fca109">&#9670;&#160;</a></span>broadcast_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> broadcast_address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the broadcast address of this network. </p>
<p>The broadcast address is the last address in the network and is used to communicate with all hosts on this network.</p>
<dl class="section return"><dt>Returns</dt><dd>The broadcast address of the network as an ip address object. </dd></dl>

</div>
</div>
<a id="a7814fc154e2054cc8caea2f97996bc9a" name="a7814fc154e2054cc8caea2f97996bc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7814fc154e2054cc8caea2f97996bc9a">&#9670;&#160;</a></span>netmask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline const <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &amp; netmask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the netmask of this network. </p>
<p>This method returns the netmask of the network. The netmask is used to determine which portion of an IP address is the network portion and which is the host portion.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the netmask as an ip address object. </dd></dl>

</div>
</div>
<a id="a34efffb7567ae9f6528aeef9fe76a469" name="a34efffb7567ae9f6528aeef9fe76a469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34efffb7567ae9f6528aeef9fe76a469">&#9670;&#160;</a></span>hostmask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> hostmask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hostmask of this network. </p>
<p>The hostmask identifies the portion of the IP address that is allocated for host identifiers.</p>
<dl class="section return"><dt>Returns</dt><dd>The hostmask of the network as an ip address object. </dd></dl>

</div>
</div>
<a id="ad4cd6479c08209e28e1320a72f708686" name="ad4cd6479c08209e28e1320a72f708686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cd6479c08209e28e1320a72f708686">&#9670;&#160;</a></span>prefixlen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline size_t prefixlen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the prefix length of this network. </p>
<p>This method returns the prefix length of the network. The prefix length is the number of bits in the network address portion of the IP address and is used to calculate the netmask.</p>
<dl class="section return"><dt>Returns</dt><dd>The prefix length of the network as a size_t value. </dd></dl>

</div>
</div>
<a id="a28d509ad04e4e88eea0d5f21037632ca" name="a28d509ad04e4e88eea0d5f21037632ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d509ad04e4e88eea0d5f21037632ca">&#9670;&#160;</a></span>is_multicast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_multicast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a multicast network. </p>
<p>This method determines whether the network is a multicast network by checking if both the network address and the broadcast address are multicast addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is multicast, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc3171.html">RFC 3171</a> for IPv4. </dd>
<dd>
<a href="https://datatracker.ietf.org/doc/html/rfc2373.html">RFC 2373</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a30c5dfb1a24f7a177abe288df2fe1b4b" name="a30c5dfb1a24f7a177abe288df2fe1b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c5dfb1a24f7a177abe288df2fe1b4b">&#9670;&#160;</a></span>is_private()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_private </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a private network. </p>
<p>This method determines whether the network is a private network. Private networks are not routed on the global internet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is private, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">iana-ipv4-special-registry</a>. </dd>
<dd>
<a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">iana-ipv6-special-registry</a>. </dd></dl>

</div>
</div>
<a id="a9c0a20a93632cde3137e0ddd2b51e4f5" name="a9c0a20a93632cde3137e0ddd2b51e4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0a20a93632cde3137e0ddd2b51e4f5">&#9670;&#160;</a></span>is_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_global </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a global network. </p>
<p>This method determines whether the network is a global network. Global networks are routable on the internet and are not private.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is global, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml">iana-ipv4-special-registry</a>. </dd>
<dd>
<a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml">iana-ipv6-special-registry</a>. </dd></dl>

</div>
</div>
<a id="a4087941a260e1e8471dcaf9aa900c94d" name="a4087941a260e1e8471dcaf9aa900c94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4087941a260e1e8471dcaf9aa900c94d">&#9670;&#160;</a></span>is_reserved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_reserved </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a reserved network. </p>
<p>This method determines whether the network is reserved by checking if both the network address and the broadcast address are reserved addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is reserved, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae32e93e8e8ea4eebf9ae51e6d1bfefaf" name="ae32e93e8e8ea4eebf9ae51e6d1bfefaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32e93e8e8ea4eebf9ae51e6d1bfefaf">&#9670;&#160;</a></span>is_loopback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_loopback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a loopback network. </p>
<p>This method determines whether the network is a loopback network by checking if both the network address and the broadcast address are loopback addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is loopback, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc3330.html">RFC 3330</a> for IPv4. </dd>
<dd>
<a href="https://datatracker.ietf.org/doc/html/rfc2373.html">RFC 2373</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a48625896416a27deb6f4b131c4dbffbd" name="a48625896416a27deb6f4b131c4dbffbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48625896416a27deb6f4b131c4dbffbd">&#9670;&#160;</a></span>is_link_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_link_local </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is a link-local network. </p>
<p>This method determines whether the network is a link-local network by checking if both the network address and the broadcast address are link-local addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is link-local, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc3927.html">RFC 3927</a>. </dd></dl>

</div>
</div>
<a id="a8bfed15a9f11a663033a52142e71bc26" name="a8bfed15a9f11a663033a52142e71bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfed15a9f11a663033a52142e71bc26">&#9670;&#160;</a></span>is_unspecified()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_unspecified </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the network is an unspecified network. </p>
<p>This method determines whether the network is unspecified by checking if both the network address and the broadcast address are unspecified addresses.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the network is unspecified, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc5735.html">RFC 5735</a> for IPv4. </dd>
<dd>
<a href="https://datatracker.ietf.org/doc/html/rfc2373.html">RFC 2373</a> for IPv6. </dd></dl>

</div>
</div>
<a id="a60ba25a33fe7de07c4fc1437697fc685" name="a60ba25a33fe7de07c4fc1437697fc685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ba25a33fe7de07c4fc1437697fc685">&#9670;&#160;</a></span>addresses_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="#ac038a48d937a09ee9bd737557d66fbed">uint_type</a> addresses_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the total number of addresses in the network. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of addresses in the network as a <code>uint_type</code> value. </dd></dl>

</div>
</div>
<a id="a5c19443fa46e2546940326bbc2498947" name="a5c19443fa46e2546940326bbc2498947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c19443fa46e2546940326bbc2498947">&#9670;&#160;</a></span>hosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline hosts_sequence&lt; <a class="el" href="#aa3eb26f878db2cbaaa0541725fbf87f6">ip_address_type</a> &gt; hosts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a sequence of host addresses in the network. </p>
<p>This method returns a sequence of host addresses within the network, excluding the network and broadcast addresses.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> hosts_sequence = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/29&quot;</span>).<a class="code hl_function" href="#a5c19443fa46e2546940326bbc2498947">hosts</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; addr : hosts_sequence) {</div>
<div class="line">   std::cout &lt;&lt; addr &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.1</span></div>
<div class="line"><span class="comment">// 192.0.2.2</span></div>
<div class="line"><span class="comment">// 192.0.2.3</span></div>
<div class="line"><span class="comment">// 192.0.2.4</span></div>
<div class="line"><span class="comment">// 192.0.2.5</span></div>
<div class="line"><span class="comment">// 192.0.2.6</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_a5c19443fa46e2546940326bbc2498947"><div class="ttname"><a href="#a5c19443fa46e2546940326bbc2498947">ipaddress::ip_network_base::hosts</a></div><div class="ttdeci">constexpr inline hosts_sequence&lt; ip_address_type &gt; hosts() const noexcept</div><div class="ttdoc">Retrieves a sequence of host addresses in the network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:815</div></div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>A <code>hosts_sequence</code> object representing the sequence of host addresses. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Ipv4</td><td>The usable hosts are all the IP addresses that belong to the network, except the network address itself and the network broadcast address. For networks with a mask length of 31, the network address and network broadcast address are also included in the result. Networks with a mask of 32 will return a list containing the single host address. </td></tr>
    <tr><td class="paramname">Ipv6</td><td>The usable hosts are all the IP addresses that belong to the network, except the Subnet-Router anycast address. For networks with a mask length of 127, the Subnet-Router anycast address is also included in the result. Networks with a mask of 128 will return a list containing the single host address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Please note that with IPv6, the number of addresses can be so large that iterating through them all may be practically impossible. Therefore, use the <a class="el" href="#a5c19443fa46e2546940326bbc2498947" title="Retrieves a sequence of host addresses in the network.">hosts()</a> method cautiously to avoid endlessly retrieving addresses. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code>hosts_sequence</code> uses lazy evaluation to iterate addresses. </dd></dl>

</div>
</div>
<a id="a313860fe97d2b9d69424a19eccfd1e19" name="a313860fe97d2b9d69424a19eccfd1e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313860fe97d2b9d69424a19eccfd1e19">&#9670;&#160;</a></span>address_exclude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt; address_exclude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the network definitions resulting from removing the given network from this one. </p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.1/32&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> exclude_sequence = a.address_exclude(b);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : exclude_sequence) {</div>
<div class="line">   std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.8/29</span></div>
<div class="line"><span class="comment">// 192.0.2.4/30</span></div>
<div class="line"><span class="comment">// 192.0.2.2/31</span></div>
<div class="line"><span class="comment">// 192.0.2.0/32</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other network to exclude from this network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> object representing the remaining address ranges. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a></td><td>Raise if network is not completely contained in this network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> uses lazy evaluation to iterate networks. </dd></dl>

</div>
</div>
<a id="af6971f8b114c32d88fece634544858e1" name="af6971f8b114c32d88fece634544858e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6971f8b114c32d88fece634544858e1">&#9670;&#160;</a></span>address_exclude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1exclude__network__sequence.html">exclude_network_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt; address_exclude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the network definitions resulting from removing the given network from this one, with error handling. </p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/28&quot;</span>);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> b = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.1/32&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> err = <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">error_code::no_error</a>;</div>
<div class="line"><span class="keyword">auto</span> exclude_sequence = a.address_exclude(b, err);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (err == <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">error_code::no_error</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : exclude_sequence) {</div>
<div class="line">       std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.8/29</span></div>
<div class="line"><span class="comment">// 192.0.2.4/30</span></div>
<div class="line"><span class="comment">// 192.0.2.2/31</span></div>
<div class="line"><span class="comment">// 192.0.2.0/32</span></div>
<div class="ttc" id="anamespaceipaddress_html_a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0"><div class="ttname"><a href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">ipaddress::error_code::no_error</a></div><div class="ttdeci">@ no_error</div><div class="ttdoc">Indicates the absence of any errors.</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The other network to exclude from this network. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> object representing the remaining address ranges, or an empty sequence if an error occurs. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1exclude__network__sequence.html" title="A sequence container for networks excluding specified subnets.">exclude_network_sequence</a></code> uses lazy evaluation to iterate networks. </dd></dl>

</div>
</div>
<a id="a6aaaf38fa1199c9b5a4831bbde619ac4" name="a6aaaf38fa1199c9b5a4831bbde619ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaaf38fa1199c9b5a4831bbde619ac4">&#9670;&#160;</a></span>subnets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt; subnets </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen_diff</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of subnets from this network. </p>
<p>The subnets that join to make the current network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be increased by. new_prefix is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of <em>prefixlen_diff</em> and new_prefix must be set.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a> = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/24&quot;</span>).<a class="code hl_function" href="#a6aaaf38fa1199c9b5a4831bbde619ac4">subnets</a>(2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>) {</div>
<div class="line">   std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.0/26</span></div>
<div class="line"><span class="comment">// 192.0.2.64/26</span></div>
<div class="line"><span class="comment">// 192.0.2.128/26</span></div>
<div class="line"><span class="comment">// 192.0.2.192/26</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_a6aaaf38fa1199c9b5a4831bbde619ac4"><div class="ttname"><a href="#a6aaaf38fa1199c9b5a4831bbde619ac4">ipaddress::ip_network_base::subnets</a></div><div class="ttdeci">constexpr inline subnets_sequence&lt; ip_network_base&lt; Base &gt; &gt; subnets(size_t prefixlen_diff=1, optional&lt; size_t &gt; new_prefixlen=nullptr) const</div><div class="ttdoc">Generates a sequence of subnets from this network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:921</div></div>
<div class="ttc" id="aclassipaddress_1_1subnets__sequence_html"><div class="ttname"><a href="classipaddress_1_1subnets__sequence.html">ipaddress::subnets_sequence</a></div><div class="ttdoc">A sequence container for subnet ranges within a network.</div><div class="ttdef"><b>Definition</b> ip-network-iterator.hpp:678</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen_diff</td><td>The difference in prefix length for the subnets. <em>Defaults to 1</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_prefixlen</td><td>An optional new prefix length for the subnets. If not specified, the prefix length is determined by adding <em>prefixlen_diff</em> to the current prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classipaddress_1_1subnets__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_sequence</a></code> object representing the sequence of subnets. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a></td><td>Raised if the operation cannot be performed due to invalid parameters or prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1subnets__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_sequence</a></code> uses lazy evaluation to iterate over the subnets. </dd></dl>

</div>
</div>
<a id="a87caa83096cee9c1f1f4463d5fa9e676" name="a87caa83096cee9c1f1f4463d5fa9e676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87caa83096cee9c1f1f4463d5fa9e676">&#9670;&#160;</a></span>subnets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>&lt; <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &gt; subnets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen_diff</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence of subnets from this network with error handling. </p>
<p>The subnets that join to make the current network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be increased by. new_prefix is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of <em>prefixlen_diff</em> and new_prefix must be set.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> err = <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">error_code::no_error</a>;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a> = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/24&quot;</span>).<a class="code hl_function" href="#a6aaaf38fa1199c9b5a4831bbde619ac4">subnets</a>(err, 2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (err == <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">error_code::no_error</a>) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; net : <a class="code hl_class" href="classipaddress_1_1subnets__sequence.html">subnets_sequence</a>) {</div>
<div class="line">       std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.2.0/26</span></div>
<div class="line"><span class="comment">// 192.0.2.64/26</span></div>
<div class="line"><span class="comment">// 192.0.2.128/26</span></div>
<div class="line"><span class="comment">// 192.0.2.192/26</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during the operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen_diff</td><td>The difference in prefix length for the subnets. <em>Defaults to 1</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_prefixlen</td><td>An optional new prefix length for the subnets. If not specified, the prefix length is determined by adding <em>prefixlen_diff</em> to the current prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classipaddress_1_1subnets__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_sequence</a></code> object representing the sequence of subnets, or an empty sequence if an error occurs. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><code><a class="el" href="classipaddress_1_1subnets__sequence.html" title="A sequence container for subnet ranges within a network.">subnets_sequence</a></code> uses lazy evaluation to iterate over the subnets. </dd></dl>

</div>
</div>
<a id="a44d5d205e66991dde943eaf77e8671ad" name="a44d5d205e66991dde943eaf77e8671ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d5d205e66991dde943eaf77e8671ad">&#9670;&#160;</a></span>supernet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; supernet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen_diff</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a supernet from this network. </p>
<p>The supernet containing this network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be decreased by. new_prefix is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of <em>prefixlen_diff</em> and new_prefix must be set.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_function" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a> = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/24&quot;</span>).<a class="code hl_function" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a>(2);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <a class="code hl_function" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.0.0/22</span></div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html_a44d5d205e66991dde943eaf77e8671ad"><div class="ttname"><a href="#a44d5d205e66991dde943eaf77e8671ad">ipaddress::ip_network_base::supernet</a></div><div class="ttdeci">constexpr inline ip_network_base&lt; Base &gt; supernet(size_t prefixlen_diff=1, optional&lt; size_t &gt; new_prefixlen=nullptr) const</div><div class="ttdoc">Generates a supernet from this network.</div><div class="ttdef"><b>Definition</b> ip-network-base.hpp:1010</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen_diff</td><td>The amount by which the prefix length should be decreased. <em>Defaults to 1</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_prefixlen</td><td>An optional new prefix length for the supernet. If not specified, the prefix length is determined by subtracting <em>prefixlen_diff</em> from the current prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the supernet, or the current network if an error occurs. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a></td><td>Raised if the operation cannot be performed due to invalid parameters or prefix length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa840d739050d32deed4571088353c87" name="afa840d739050d32deed4571088353c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa840d739050d32deed4571088353c87">&#9670;&#160;</a></span>supernet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; supernet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689d">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>prefixlen_diff</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipaddress_1_1optional.html">optional</a>&lt; size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_prefixlen</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a supernet from this network with error handling. </p>
<p>The supernet containing this network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be decreased by. new_prefix is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of <em>prefixlen_diff</em> and new_prefix must be set.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> err = <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">error_code::no_error</a>;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a> = <a class="code hl_function" href="#a1ff563ad415ed4e9179472b3ec80caee">ipv4_network::parse</a>(<span class="stringliteral">&quot;192.0.2.0/24&quot;</span>).<a class="code hl_function" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a>(err, 2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (err == <a class="code hl_enumvalue" href="namespaceipaddress.html#a88a76ee847c844cc47b94caac600689da7fa49f1a086c46bfc9e5f5fe279a82c0">error_code::no_error</a>) {</div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_function" href="#a44d5d205e66991dde943eaf77e8671ad">supernet</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// out:</span></div>
<div class="line"><span class="comment">// 192.0.0.0/22</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">code</td><td>An error_code object that will be set if an error occurs during the operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixlen_diff</td><td>The amount by which the prefix length should be decreased. <em>Defaults to 1</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_prefixlen</td><td>An optional new prefix length for the supernet. If not specified, the prefix length is determined by subtracting <em>prefixlen_diff</em> from the current prefix length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ip network object representing the supernet, or the current network if an error occurs. </dd></dl>

</div>
</div>
<a id="a3888dcd59dd5acd1ca5b9bee4c2e252a" name="a3888dcd59dd5acd1ca5b9bee4c2e252a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3888dcd59dd5acd1ca5b9bee4c2e252a">&#9670;&#160;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator std::string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the ip network object to a std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::string</code> representation of the ip network object. </dd></dl>

</div>
</div>
<a id="a1c4f7eddba8b6535362a53fc55be74f4" name="a1c4f7eddba8b6535362a53fc55be74f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4f7eddba8b6535362a53fc55be74f4">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<p>Compares this ip network object to another for equality based on the network address and netmask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both objects are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab3131fe1d0ba16911a82b14b8eaf252b" name="ab3131fe1d0ba16911a82b14b8eaf252b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3131fe1d0ba16911a82b14b8eaf252b">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator. </p>
<p>Compares this ip network object to another for inequality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both objects are not equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8b76868bfcd0b21168ea8557716a923a" name="a8b76868bfcd0b21168ea8557716a923a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b76868bfcd0b21168ea8557716a923a">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than comparison operator. </p>
<p>Determines if this ip network object is less than another by comparing network addresses and netmasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is less than the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac069d39bdeaa1f5c5df412787b01360c" name="ac069d39bdeaa1f5c5df412787b01360c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac069d39bdeaa1f5c5df412787b01360c">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than comparison operator. </p>
<p>Determines if this ip network object is greater than another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is greater than the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a354e42ec52dff3847595b95c80ba4f5a" name="a354e42ec52dff3847595b95c80ba4f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354e42ec52dff3847595b95c80ba4f5a">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal to comparison operator. </p>
<p>Determines if this ip network object is less than or equal to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is less than or equal to the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a26213010ba81739e1496a1a7c4f03a7e" name="a26213010ba81739e1496a1a7c4f03a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26213010ba81739e1496a1a7c4f03a7e">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt; Base &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal to comparison operator. </p>
<p>Determines if this ip network object is greater than or equal to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The other ip network object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is greater than or equal to the other, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ipaddress/<a class="el" href="ip-network-base_8hpp_source.html">ip-network-base.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceipaddress.html">ipaddress</a></li><li class="navelem"><a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
