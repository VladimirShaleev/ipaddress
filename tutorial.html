<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="ipaddress is a library for working and manipulating IPv4/IPv6 addresses and networks in modern C++.">
<meta name="google-site-verification" content="uQYFmsuPjcXUmeBoLNMqxmIJ4S__SUukKLX_xzT9sH4" />
<meta name="msvalidate.01" content="E78F7336FAA956728F9E29CB3CFC7741" />
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="ipaddress" />
<meta property="og:image" content="https://vladimirshaleev.github.io/ipaddress/constexpr.png" />
<meta property="og:description" content="A library for working and manipulating IPv4/IPv6 addresses and networks in modern C++." />
<meta property="og:url" content="https://vladimirshaleev.github.io/ipaddress/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://vladimirshaleev.github.io/ipaddress/constexpr.png" />
<meta name="twitter:title" content="ipaddress" />
<meta name="twitter:description" content="A library for working and manipulating IPv4/IPv6 addresses and networks in modern C++." />
<!-- END twitter metadata -->
<title>ipaddress: Tutorial</title>
<link rel="icon" href="logo.svg" type="image/svg+xml" />
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
<link rel="icon" sizes="16x16" href="favicon-16x16.png" type="image/png">
<link rel="icon" sizes="32x32" href="favicon-32x32.png" type="image/png">
<link rel="apple-touch-icon" sizes="57x57" href="apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
<link rel="mask-icon" color="#5f8893" href="safari-pinned-tab.svg">
<meta name="msapplication-TileColor" content="#4a9cf8">
<meta name="msapplication-TileImage" content="mstile-144x144.png">
<meta name="msapplication-square70x70logo" content="mstile-70x70.png">
<meta name="msapplication-square150x150logo" content="mstile-150x150.png">
<meta name="msapplication-wide310x150logo" content="mstile-310x310.png">
<meta name="msapplication-square310x310logo" content="mstile-310x150.png">
<meta name="msapplication-config" content="browserconfig.xml">
<meta name="application-name" content="ipaddress">
<link rel="manifest" href="site.webmanifest">
<meta name="theme-color" content="#ffffff">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/VladimirShaleev/ipaddress" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
  <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
  <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ipaddress<span id="projectnumber">&#160;1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md14">IP addresses</a><ul><li class="level3"><a href="#autotoc_md15">Parsing ip strings</a></li>
<li class="level3"><a href="#autotoc_md16">From uint/To uint</a></li>
<li class="level3"><a href="#autotoc_md17">Working with bytes</a></li>
<li class="level3"><a href="#autotoc_md18">Comparison</a></li>
<li class="level3"><a href="#autotoc_md19">Properties</a></li>
<li class="level3"><a href="#autotoc_md20">Convert to string</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md21">IP networks</a><ul><li class="level3"><a href="#autotoc_md22">Parsing ip network strings</a></li>
<li class="level3"><a href="#autotoc_md23">Create from address</a></li>
<li class="level3"><a href="#autotoc_md24">Comparison</a></li>
<li class="level3"><a href="#autotoc_md25">Properties</a></li>
<li class="level3"><a href="#autotoc_md26">Convert to string</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md27">Scope Id</a></li>
<li class="level2"><a href="#autotoc_md28">Std overrides</a></li>
</ul>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="autotoc_md14"></a>
IP addresses</h2>
<p>For working with IP addresses, the library provides three classes:</p>
<ul>
<li><b>ipv4_address</b> — A class for working with IPv4 addresses, where the instance size is always 4 bytes.</li>
<li><b>ipv6_address</b> — A class for working with IPv6 addresses, where the instance size includes both the space allocated for the IPv6 address itself and the scope id (zone index). As a result, the instance size will be 16 bytes plus the maximum length of the scope id (plus aligned bytes if any). Read about scope ids below.</li>
<li><b>ip_address</b> — Combines the <code>ipv4_address</code> and <code>ipv6_address</code> classes via a union. This ensures version-independent IP address manipulation. It has implicit constructors for converting from <code>ipv4_address</code> and <code>ipv6_address</code>. The instance size is the same as that of <code>ipv6_address</code> plus IP address version (and data alignment).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Regardless of which class you use, the internal address is stored as an array of bytes, not as an unsigned integer. This design choice ensures that the address is stored in network byte order (big-endian) regardless of the platform. This is convenient because ultimately, this address can be used in sockets or similar libraries that require passing addresses in network byte order. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All operations on addresses support compile-time computations. If an address is specified as a constant, during compilation, we get: errors if the address was entered incorrectly, the resulting IP address represented as bytes, and any other operations on addresses. </dd></dl>
<h3><a class="anchor" id="autotoc_md15"></a>
Parsing ip strings</h3>
<p>Let's look at examples of obtaining IP addresses from string literals and strings.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Parsing string literals for IPv4 and IPv6. Note that IPv6 addresses</span></div>
<div class="line">    <span class="comment">// in string form can be specified in various formats. The following addresses are equivalent:</span></div>
<div class="line">    <span class="comment">//    - fe80::1ff:fe23:4567:890a%eth2</span></div>
<div class="line">    <span class="comment">//    - FE80::1FF:FE23:4567:890A%eth2</span></div>
<div class="line">    <span class="comment">//    - fe80:0:0:0:1ff:fe23:4567:890a%eth2</span></div>
<div class="line">    <span class="comment">//    - fe80:0000:0000:0000:01ff:fe23:4567:890a%eth2</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Thanks to constexpr, for example, ip1 will be expanded into an array of bytes during compilation,</span></div>
<div class="line">    <span class="comment">// and parsing will not occur at runtime. It can be presented like this for clarity:</span></div>
<div class="line">    <span class="comment">//    constexpr const ipaddress::ipv4_address ip1 =</span></div>
<div class="line">    <span class="comment">//        {{{}, {{(unsigned char)192U, (unsigned char)168U, (unsigned char)1U, (unsigned char)1U}}}};</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ipv4_address::parse(<span class="stringliteral">&quot;192.168.1.1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ipv6_address::parse(<span class="stringliteral">&quot;64:ff9b::192.0.2.128&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip3 =   ip_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parsing string literals for IPv4 and IPv6 with the new syntax starting from C++20</span></div>
<div class="line">    <span class="comment">// (Literal Classes as Non-type Template Parameters)</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip4 = ipv4_address::parse&lt;<span class="stringliteral">&quot;192.168.1.1&quot;</span>&gt;();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip5 = ipv6_address::parse&lt;<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>&gt;();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip6 =   ip_address::parse&lt;<span class="stringliteral">&quot;192.168.1.1&quot;</span>&gt;(); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parsing with User-defined literals</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip7 = <span class="stringliteral">&quot;192.168.1.1&quot;</span>_ipv4;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip8 = <span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>_ipv6;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip9 = <span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>_ip; <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parsing at runtime. For example, when a string comes from an input </span></div>
<div class="line">    <span class="comment">// field during execution or from any other source.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>*       str1 = <span class="stringliteral">&quot;192.168.1.1&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> std::string str2 = <span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> ip10 = ipv4_address::parse(str1);</div>
<div class="line">    <span class="keyword">auto</span> ip11 = ipv6_address::parse(str2);</div>
<div class="line">    <span class="keyword">auto</span> ip12 =   ip_address::parse(str2); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aipaddress_8hpp_html"><div class="ttname"><a href="ipaddress_8hpp.html">ipaddress.hpp</a></div><div class="ttdoc">The main include file for the ipaddress library.</div></div>
<div class="ttc" id="anamespaceipaddress_html"><div class="ttname"><a href="namespaceipaddress.html">ipaddress</a></div><div class="ttdoc">Namespace dedicated to IP addresses and networks operations.</div><div class="ttdef"><b>Definition</b> base-v4.hpp:18</div></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>For compile-time computations, the <b>ipaddress</b> library uses relaxed <code>constexpr</code>, which was introduced only in C++14. Therefore, for C++11, the <b>ipaddress</b> library does not support constant expressions. It is recommended to use the C++14 language standard or newer versions.</dd></dl>
<p>Access to specific versions of IP addresses for ip_address is demonstrated below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// With ipv4_address and ipv6_address everything is clear, </span></div>
<div class="line">    <span class="comment">// everything is known from their types</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ipv4 = ipv4_address::parse(<span class="stringliteral">&quot;192.168.1.1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ipv6 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ipv4_version = ipv4.version(); <span class="comment">// V4</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ipv6_version = ipv6.version(); <span class="comment">// V6</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ipv4_size    = ipv4.size(); <span class="comment">// 4</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ipv6_size    = ipv6.size(); <span class="comment">// 16</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// But that&#39;s not the case for ip_address</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ip_address::parse(<span class="stringliteral">&quot;192.168.1.1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ip_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Below is how to distinguish between different versions of IP</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1_version = ip1.version(); <span class="comment">// V4</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_version = ip2.version(); <span class="comment">// V6</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1_size    = ip1.size(); <span class="comment">// 4</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_size    = ip2.size(); <span class="comment">// 16</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Check which IP version is stored in ip_address for ip2</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_is_v4 = ip2.is_v4(); <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_is_v6 = ip2.is_v6(); <span class="comment">// true</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to specific versions of IP addresses for ip2</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_get_ipv4 = ip2.v4();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_get_ipv6 = ip2.v6();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (ip2_get_ipv4) { <span class="comment">// false</span></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> result = ip2_get_ipv4.value();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (ip2_get_ipv6.has_value()) { <span class="comment">// true</span></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> result = ip2_get_ipv6.value(); <span class="comment">// get ipv6</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The library also supports working with Unicode C++ strings such as <b>UTF-8</b>, <b>UTF-16</b>, <b>UTF-32</b> and <b>wide-char</b> (<code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code> and <code>wchar_t</code>). For strings with a base type of <code>char</code>, it is assumed that the input string consists of an <b>ASCII</b> character sequence and is not encoded with any encoding. If your application uses the Unicode encoding <b>UTF-8</b> for incoming strings with a base type of <code>char</code>, you can define the macro <code>IPADDRESS_CHAR_IS_UTF8</code>. In this case, all incoming strings with a base type of <code>char</code> will be interpreted as <b>UTF-8</b> encoding. Despite the support for Unicode, it's important to note that for successful parsing of IP addresses, the incoming string must contain valid symbols for IP addresses.</dd></dl>
<h3><a class="anchor" id="autotoc_md16"></a>
From uint/To uint</h3>
<p>Below is code demonstrating how to create IP addresses from unsigned integers and convert them back to unsigned integers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Unsigned integers in host endianness</span></div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classipaddress_1_1ip__address__base.html#a5332dae176bf5fd604530b9f8aac1b36">ipv4_address::uint_type</a> u1 = 0xC0A80001;         <span class="comment">// std::uint32_t</span></div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classipaddress_1_1ip__address__base.html#a5332dae176bf5fd604530b9f8aac1b36">ipv6_address::uint_type</a> u2 = 281470681743360ULL; <span class="comment">// ipaddress::uint128_t</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ipv4_address::from_uint(u1);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ipv6_address::from_uint(u2);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip3 =   ip_address::from_uint(u1); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get unsigned integers in host endianness</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Explicit conversions are also available:</span></div>
<div class="line">    <span class="comment">//   - constexpr auto value1 =        (std::uint32_t) ip1;</span></div>
<div class="line">    <span class="comment">//   - constexpr auto value2 = (ipaddress::uint128_t) ip2;</span></div>
<div class="line">    <span class="comment">//   - constexpr auto value3 =        (std::uint32_t) ip3;</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> value1 = ip1.to_uint();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> value2 = ip2.to_uint();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> value3 = ip3.to_uint32(); <span class="comment">// ip_address does not define to_uint to avoid accidental errors</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassipaddress_1_1ip__address__base_html_a5332dae176bf5fd604530b9f8aac1b36"><div class="ttname"><a href="classipaddress_1_1ip__address__base.html#a5332dae176bf5fd604530b9f8aac1b36">ipaddress::ip_address_base&lt; ipv4_address_base &gt;::uint_type</a></div><div class="ttdeci">typename Base::uint_type uint_type</div><div class="ttdoc">Type alias for the underlying unsigned integer type.</div><div class="ttdef"><b>Definition</b> ip-address-base.hpp:59</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>ipaddress</code> defines its type <code>uint128_t</code> to work with 128-bit unsigned integers. It is designed to fill the gap in the C++ standard, which does not natively support 128-bit integers across all platforms. Unlike compiler-specific extensions like <code>__int128</code>, <code>uint128_t</code> ensures compatibility and portability across different compilers and architectures. <br  />
 The implementation is inspired by the algorithms used in the .NET framework's <a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/UInt128.cs">UInt128</a>, providing a reliable foundation for arithmetic operations and other integer-related functionalities.</dd></dl>
<h3><a class="anchor" id="autotoc_md17"></a>
Working with bytes</h3>
<p>Below is an example of working with bytes and pointers to bytes directly.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="classipaddress_1_1ip__address__base.html#a1be7cee0334a10989321732568ff4e23">ipv6_address::base_type</a> ipv6_bytes { </div>
<div class="line">        0, 0, 0, 0,</div>
<div class="line">        0, 0, 0, 0,</div>
<div class="line">        0, 0, 255, 255,</div>
<div class="line">        0, 0, 0, 0</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Creating IP addresses from byte arrays of a fixed size</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ipv4_address::from_bytes({ 0xC0, 0xA8, 0x00, 0x01 });</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ipv6_address::from_bytes(ipv6_bytes);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip3 =   ip_address::from_bytes(ipv6_bytes); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Creation from a pointer to bytes. </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//    If the number of bytes is less than the target number  of bytes to represent </span></div>
<div class="line">    <span class="comment">//    the IP address, the missing bytes will be filled with zeros.</span></div>
<div class="line">    <span class="comment">//    </span></div>
<div class="line">    <span class="comment">//    If the number of bytes is greater than the target number of bytes represented </span></div>
<div class="line">    <span class="comment">//    by the IP address, then the extra bytes will be ignored.</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="keyword">constexpr</span> std::uint8_t ipv4_bytes[] = { 0xC0, 0xA8, 0x00, 0x01 };</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> iv4 = ipv4_address::from_bytes(ipv4_bytes, 3);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> iv5 = ipv6_address::from_bytes(ipv4_bytes, 3);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip6 =   ip_address::from_bytes(ipv4_bytes, 3,  ip_version::V4);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip7 =   ip_address::from_bytes(ipv6_bytes.data(), 11, ip_version::V6);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// bytes() provides read access to fixed-length byte arrays</span></div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">    <span class="comment">//    A fixed-size byte array is represented by the byte_array type.</span></div>
<div class="line">    <span class="comment">//    It provides full functionality for byte access and iterators.</span></div>
<div class="line">    <span class="comment">//    std::array is not used because before C++17 it was not able to work </span></div>
<div class="line">    <span class="comment">//    with constant expressions for iterators, etc.</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1_byte_count = ip1.bytes().size(); <span class="comment">// 4</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2_byte_count = ip2.bytes().size(); <span class="comment">// 16</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip3_byte_count = ip3.is_v4() </div>
<div class="line">        ? ip3.v4().value().bytes().size() </div>
<div class="line">        : ip3.v6().value().bytes().size();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// data() provides a constant pointer to a byte array</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test1 = *(ip1.data() + 1);  <span class="comment">// 168</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test2 = *(ip2.data() + 10); <span class="comment">// 255</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test3 = *(ip3.data() + 11); <span class="comment">// 255</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassipaddress_1_1ip__address__base_html_a1be7cee0334a10989321732568ff4e23"><div class="ttname"><a href="classipaddress_1_1ip__address__base.html#a1be7cee0334a10989321732568ff4e23">ipaddress::ip_address_base&lt; ipv6_address_base &gt;::base_type</a></div><div class="ttdeci">typename Base::base_type base_type</div><div class="ttdoc">Type alias for the base storage type.</div><div class="ttdef"><b>Definition</b> ip-address-base.hpp:58</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
Comparison</h3>
<p>For classes for working with IP addresses, comparison operators and spaceship operator (for C++20 and newer) have been redefined.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890b&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test1 = ip1 == ip2; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test2 = ip1 != ip2; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test3 = ip1 &lt;  ip2; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test4 = ip1 &lt;= ip2; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test5 = ip1 &gt;= ip2; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test6 = ip1 &gt;  ip2; <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If scope id is specified, it will also be taken into account when comparing</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip3 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip4 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth1&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test7  = ip2 == ip3; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test8  = ip2 != ip3; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test9  = ip2 &lt;  ip3; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test10 = ip2 &lt;= ip3; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test11 = ip2 &gt;= ip3; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test12 = ip2 &gt;  ip3; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test13 = ip3 == ip4; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test14 = ip3 != ip4; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test15 = ip3 &lt;  ip4; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test16 = ip3 &lt;= ip4; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test17 = ip3 &gt;= ip4; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test18 = ip3 &gt;  ip4; <span class="comment">// true</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Properties</h3>
<p>The library provides many properties for determining certain features of an IP address. Let's look at the example below (all possible properties are not presented here; for a more complete picture, see the <a href="classipaddress_1_1ip__address.html#pub-methods">documentation for the code</a>).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test1 = ipv6_address::parse(<span class="stringliteral">&quot;ffff::&quot;</span>).is_multicast(); <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test2 =   ip_address::parse(<span class="stringliteral">&quot;fdff::&quot;</span>).is_multicast(); <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test3 = ipv4_address::parse(<span class="stringliteral">&quot;240.0.0.1&quot;</span>).is_reserved(); <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test4 =   ip_address::parse(<span class="stringliteral">&quot;239.255.255.255&quot;</span>).is_reserved(); <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip = ip_address::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> sixtofour = ip.sixtofour(); <span class="comment">// get sixtofour</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (sixtofour) { <span class="comment">// true</span></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> result = sixtofour.value();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
Convert to string</h3>
<p>There are three different formats for converting IP addresses to strings as you can see below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// For IP addresses version 4, the format has no effect</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ipv4_address::parse(<span class="stringliteral">&quot;127.240.0.1&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> str1 = ip1.to_string();                   <span class="comment">// equivalent to format::compressed</span></div>
<div class="line">    <span class="keyword">auto</span> str2 = ip1.to_string(format::full);       <span class="comment">// 127.240.0.1</span></div>
<div class="line">    <span class="keyword">auto</span> str3 = ip1.to_string(format::compact);    <span class="comment">// 127.240.0.1</span></div>
<div class="line">    <span class="keyword">auto</span> str4 = ip1.to_string(format::compressed); <span class="comment">// 127.240.0.1</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> str5 = ip2.to_string();                   <span class="comment">// equivalent to format::compressed </span></div>
<div class="line">    <span class="keyword">auto</span> str6 = ip2.to_string(format::full);       <span class="comment">// fe80:0000:0000:0000:01ff:fe23:4567:890a%eth2</span></div>
<div class="line">    <span class="keyword">auto</span> str7 = ip2.to_string(format::compact);    <span class="comment">// fe80:0:0:0:1ff:fe23:4567:890a%eth2</span></div>
<div class="line">    <span class="keyword">auto</span> str8 = ip2.to_string(format::compressed); <span class="comment">// fe80::1ff:fe23:4567:890a%eth2</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> reverse_pointer = ip2.reverse_pointer(); <span class="comment">// a.0.9.8.7.6.5.4.3.2.e.f.f.f.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
IP networks</h2>
<ul>
<li><b>ipv4_network</b> — A class for working with IPv4 networks.</li>
<li><b>ipv6_network</b> — A class for working with IPv6 networks.</li>
<li><b>ip_network</b> — Combines the <code>ipv4_network</code> and <code>ipv6_network</code> classes via a union. This ensures version-independent IP address manipulation. It has implicit constructors for converting from <code>ipv4_network</code> and <code>ipv6_network</code>. The instance size is the same as that of <code>ipv6_network</code>.</li>
</ul>
<p>Networks store two IP addresses (network address and netmask), as well as the prefix length. This means that the size of a network instance will be <code>2 * sizeof(&lt;ip_type&gt;) + sizeof(size_t)</code>.</p>
<p>Working with networks is similar to working with addresses. So let's get straight to the examples.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Parsing ip network strings</h3>
<p>Let's look at examples of obtaining networks from string literals and strings.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Parsing string literals for IPv4 and IPv6</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// For ipv4: </span></div>
<div class="line">    <span class="comment">//    if the mask (portion after the / in the argument) is provided in dotted </span></div>
<div class="line">    <span class="comment">//    quad form, it is considered a netmask if it begins with a non-zero field </span></div>
<div class="line">    <span class="comment">//    (e.g., /255.0.0.0 corresponds to a /8 netmask). Conversely, if it starts </span></div>
<div class="line">    <span class="comment">//    with a zero field (e.g., 0.255.255.255), it is treated as a hostmask for </span></div>
<div class="line">    <span class="comment">//    the /8 prefix. The only exception is an all-zero mask, which is treated </span></div>
<div class="line">    <span class="comment">//    as a netmask equivalent to /0. If no mask is specified, the default is /32</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net1 = ipv4_network::parse(<span class="stringliteral">&quot;1.2.3.0/24&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net2 = ipv6_network::parse(<span class="stringliteral">&quot;2001:db8::/32&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net3 =   ip_network::parse(<span class="stringliteral">&quot;1.2.3.4/255.255.255.255&quot;</span>); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parsing string literals for IPv4 and IPv6 with the new syntax starting from C++20</span></div>
<div class="line">    <span class="comment">// (Literal Classes as Non-type Template Parameters)</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net4 = ipv4_network::parse&lt;<span class="stringliteral">&quot;1.2.3.0/24&quot;</span>&gt;();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net5 = ipv6_network::parse&lt;<span class="stringliteral">&quot;2001:db8::/32&quot;</span>&gt;();</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net6 =   ip_network::parse&lt;<span class="stringliteral">&quot;1.2.3.4/255.255.255.255&quot;</span>&gt;(); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parsing with User-defined literals</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net7 = <span class="stringliteral">&quot;1.2.3.0/24&quot;</span>_ipv4_net;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net8 = <span class="stringliteral">&quot;2001:db8::/32&quot;</span>_ipv6_net;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net9 = <span class="stringliteral">&quot;1.2.3.4/255.255.255.255&quot;</span>_net; <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parsing at runtime. For example, when a string comes from an input </span></div>
<div class="line">    <span class="comment">// field during execution or from any other source.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>*       str1 = <span class="stringliteral">&quot;1.2.3.0/24&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> std::string str2 = <span class="stringliteral">&quot;2001:db8::/32&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> net10 = ipv4_network::parse(str1);</div>
<div class="line">    <span class="keyword">auto</span> net11 = ipv6_network::parse(str2);</div>
<div class="line">    <span class="keyword">auto</span> net12 =   ip_network::parse(str2); <span class="comment">// any version address</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If the prefixlen is not present in the input string, then the length of the prefix will be equal to the maximum length (for ipv4 it is 32, and for ipv6 it is 128)</dd></dl>
<p>We can request various network parameters.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net1 = ip_network::parse(<span class="stringliteral">&quot;2001:db8::/32&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> network_address1 = net1.network_address(); <span class="comment">// 2001:db8::</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> broadcast_address1 = net1.broadcast_address(); <span class="comment">// 2001:db8:ffff:ffff:ffff:ffff:ffff:ffff</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> netmask1 = net1.netmask(); <span class="comment">// ffff:ffff::</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> hostmask1 = net1.hostmask(); <span class="comment">// ::ffff:ffff:ffff:ffff:ffff:ffff</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> prefixlen1 = net1.prefixlen(); <span class="comment">// 32</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net2 = ip_network::parse(<span class="stringliteral">&quot;1.2.3.0/255.255.255.0&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> network_address2 = net2.network_address(); <span class="comment">// 1.2.3.0</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> broadcast_address2 = net2.broadcast_address(); <span class="comment">// 1.2.3.255</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> netmask2 = net2.netmask(); <span class="comment">// 255.255.255.0</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> hostmask2 = net2.hostmask(); <span class="comment">// 0.0.0.255</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> prefixlen2 = net2.prefixlen(); <span class="comment">// 24</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Non strict mode sample</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net3 = ip_network::parse(<span class="stringliteral">&quot;1.2.3.0/16&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> network_address3 = net3.network_address(); <span class="comment">// 1.2.0.0</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> broadcast_address3 = net3.broadcast_address(); <span class="comment">// 1.2.255.255</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> netmask3 = net3.netmask(); <span class="comment">// 255.255.0.0</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> hostmask3 = net3.hostmask(); <span class="comment">// 0.0.255.255</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> prefixlen3 = net3.prefixlen(); <span class="comment">// 16</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
Create from address</h3>
<p>A network can be created from an IP address and a prefixlen.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip4 = ipv4_address::parse(<span class="stringliteral">&quot;192.168.0.1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip6 = ipv6_address::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip_any = ip_address::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_class" href="classipaddress_1_1ip__network__base.html">ipv4_network</a> net1 = ipv4_network::from_address(ip4, 24, <span class="keyword">false</span>); <span class="comment">// non strict mode sample</span></div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_class" href="classipaddress_1_1ip__network__base.html">ipv6_network</a> net2 = ipv6_network::from_address(ip6, 64);</div>
<div class="line">    <span class="keyword">constexpr</span>   <a class="code hl_class" href="classipaddress_1_1ip__network.html">ip_network</a> net3 =   ip_network::from_address(ip4, 32);</div>
<div class="line">    <span class="keyword">constexpr</span>   <a class="code hl_class" href="classipaddress_1_1ip__network.html">ip_network</a> net4 =   ip_network::from_address(ip6, 64);</div>
<div class="line">    <span class="keyword">constexpr</span>   <a class="code hl_class" href="classipaddress_1_1ip__network.html">ip_network</a> net5 =   ip_network::from_address(ip_any, 64);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassipaddress_1_1ip__network__base_html"><div class="ttname"><a href="classipaddress_1_1ip__network__base.html">ipaddress::ip_network_base&lt; ipv4_network_base &gt;</a></div></div>
<div class="ttc" id="aclassipaddress_1_1ip__network_html"><div class="ttname"><a href="classipaddress_1_1ip__network.html">ipaddress::ip_network</a></div><div class="ttdoc">A class that encapsulates both IPv4 and IPv6 network functionalities.</div><div class="ttdef"><b>Definition</b> ip-any-network.hpp:70</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Comparison</h3>
<p>For classes for working with IP networks, comparison operators and spaceship operator (for C++20 and newer) have been redefined.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net1 = ip_network::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::/64&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net2 = ip_network::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::&quot;</span>); <span class="comment">// this is the same as 2002:ac1d:2d64::/128</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test1 = net1 == net2; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test2 = net1 != net2; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test3 = net1 &lt;  net2; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test4 = net1 &lt;= net2; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test5 = net1 &gt;= net2; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test6 = net1 &gt;  net2; <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net3 = ip_network::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::/64&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net4 = ip_network::parse(<span class="stringliteral">&quot;2002:ac1d:2d64::%1/64&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test7  = net2 == net3; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test8  = net2 != net3; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test9  = net2 &lt;  net3; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test10 = net2 &lt;= net3; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test11 = net2 &gt;= net3; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test12 = net2 &gt;  net3; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test13 = net3 == net4; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test14 = net3 != net4; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test15 = net3 &lt;  net4; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test16 = net3 &lt;= net4; <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test17 = net3 &gt;= net4; <span class="comment">// false</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test18 = net3 &gt;  net4; <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
Properties</h3>
<p>The library provides many properties for determining certain features of an IP network. Let's look at the example below (all possible properties are not presented here; for a more complete picture, see the <a href="classipaddress_1_1ip__network.html#pub-methods">documentation for the code</a>).</p>
<p>As you can see, getting network properties is not much different from getting address properties.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test1 = ipv6_network::parse(<span class="stringliteral">&quot;ffff::&quot;</span>).is_multicast(); <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test2 =   ip_network::parse(<span class="stringliteral">&quot;fdff::&quot;</span>).is_multicast(); <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test3 = ipv4_network::parse(<span class="stringliteral">&quot;240.0.0.1&quot;</span>).is_reserved(); <span class="comment">// true</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> test4 =   ip_network::parse(<span class="stringliteral">&quot;239.255.255.255&quot;</span>).is_reserved(); <span class="comment">// false</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Convert to string</h3>
<p>There are three different formats for converting IP networks to strings as you can see below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// For IP addresses version 4, the format has no effect</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net1 = ip_network::parse(<span class="stringliteral">&quot;1.2.3.0/0.0.0.255&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> str1 = net1.to_string(); <span class="comment">// 1.2.3.0/24</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> net2 = ip_network::parse(<span class="stringliteral">&quot;2001:db8::/32&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> str2 = net2.to_string();                   <span class="comment">// equivalent to format::compressed</span></div>
<div class="line">    <span class="keyword">auto</span> str3 = net2.to_string(format::full);       <span class="comment">// 2001:0db8:0000:0000:0000:0000:0000:0000/32</span></div>
<div class="line">    <span class="keyword">auto</span> str4 = net2.to_string(format::compact);    <span class="comment">// 2001:db8:0:0:0:0:0:0/32</span></div>
<div class="line">    <span class="keyword">auto</span> str5 = net2.to_string(format::compressed); <span class="comment">// 2001:db8::/32</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Scope Id</h2>
<p>The library supports <b>Scope Id</b> both as numeric values and as strings.</p>
<p>By default, <b>Scope Id</b> are enabled, and their maximum size is 16 characters (defined by <code>IPADDRESS_IPV6_SCOPE_MAX_LENGTH</code> during compilation). Yes, the <b>scope id</b> is internally represented as a fixed-size array, and its maximum size cannot be changed dynamically. This means that you cannot store a <b>scope id</b> longer than <code>IPADDRESS_IPV6_SCOPE_MAX_LENGTH</code>. There are several reasons for this design choice: simplicity in storing <b>scope id</b>, avoiding additional allocations (all data for the IP address will be as local as possible in memory), and enabling working with <b>scope id</b> in a <b>constexpr</b> manner.</p>
<dl class="section note"><dt>Note</dt><dd>If you are certain that you don't need <b>Scope Id</b>, you can completely disable them to avoid any overhead related to their maintenance. This can be done by defining <code>IPADDRESS_NO_IPV6_SCOPE</code> during compilation. In this case, the instance size of <code>ipv6_address</code> and <code>ip_address</code> will be 16 bytes, and all operations related to retrieving or modifying the <b>scope id</b> will have no effect.</dd></dl>
<p>For IP addresses <code>ipv6_address</code> and <code>ip_address</code>, functionality is supported for obtaining and changing scope id.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ipv6_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a%eth2&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> scope_id = ip1.get_scope_id();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (scope_id) {</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> is_integer = scope_id.has_uint32(); <span class="comment">// false</span></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> is_string = scope_id.has_string(); <span class="comment">// true</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;scope id is integer for ip1: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; is_integer &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;scope id is string for ip1: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; is_string &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;scope id for ip1: &quot;</span> &lt;&lt; scope_id.get_string() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If IPv4 is stored in ip_address, then methods for working with the scope id have no effect</span></div>
<div class="line">    <span class="keyword">auto</span> ip2 = ip_address::parse(<span class="stringliteral">&quot;fe80::1ff:fe23:4567:890a&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;has scope id for ip2: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; (bool) ip2.get_scope_id() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    ip2.set_scope_id(<span class="stringliteral">&quot;123&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> test_scope_id = ip2.get_scope_id();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (test_scope_id) {</div>
<div class="line">        <span class="keyword">auto</span> is_integer = test_scope_id.has_uint32(); <span class="comment">// true</span></div>
<div class="line">        <span class="keyword">auto</span> is_string = test_scope_id.has_string(); <span class="comment">// true</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;scope id is integer for ip2: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; is_integer &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;scope id is string for ip2: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; is_string &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;scope id for ip2: &quot;</span> &lt;&lt; test_scope_id.get_uint32() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>By default, the use of whitespace characters in the scope id is not permitted. If a whitespace character is found in the incoming string within the scope id (for example, <code>fe80::1ff:fe23:4567:890aet h2</code>), an error with the code <code>error_code::invalid_scope_id</code> will be generated. However, if for some reason you need to parse and save spaces in the scope id, you can define the macro <code>IPADDRESS_SCOPE_ID_SUPPORT_SPACES</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md28"></a>
Std overrides</h2>
<dl class="section note"><dt>Note</dt><dd>If, for some reason, you don't want the library to overload standard functions, you can define <code>IPADDRESS_NO_OVERLOAD_STD</code> during compilation.</dd></dl>
<p>The library overloads some functions from the standard library so that IP addresses and networks (<code>ipv4_address</code>, <code>ipv6_address</code>, <code>ip_address</code>, <code>ipv4_network</code>, <code>ipv6_network</code> and <code>ip_network</code>) can be used in hash tables and other standard operations on <code>std::swap</code>, etc.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ipaddress_8hpp.html">ipaddress/ipaddress.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceipaddress.html">ipaddress</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip1 = ip_address::parse(<span class="stringliteral">&quot;127.0.0.1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip2 = ip_address::parse(<span class="stringliteral">&quot;2001:db8::1&quot;</span>);</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> ip3 = ip_address::parse(<span class="stringliteral">&quot;2001:db8::1%scope&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Added partial specialization for hash calculation</span></div>
<div class="line">    std::unordered_map&lt;ip_address, int&gt; container;</div>
<div class="line">    container[ip1] = 1;</div>
<div class="line">    container[ip2] = 2;</div>
<div class="line">    container[ip3] = 3;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [key, value] : container) {</div>
<div class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Overloaded operators for parsing and writing to streams (char type only)</span></div>
<div class="line">    std::cout &lt;&lt; ip2 &lt;&lt; std::endl; <span class="comment">// 2001:db8::1</span></div>
<div class="line">    std::cout &lt;&lt; full &lt;&lt; ip2 &lt;&lt; std::endl; <span class="comment">// 2001:0db8:0000:0000:0000:0000:0000:0001</span></div>
<div class="line">    std::cout &lt;&lt; compact &lt;&lt; ip2 &lt;&lt; std::endl; <span class="comment">// 2001:db8:0:0:0:0:0:1</span></div>
<div class="line">    std::cout &lt;&lt; compressed &lt;&lt; ip2 &lt;&lt; std::endl; <span class="comment">// 2001:db8::1</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classipaddress_1_1ip__address.html">ip_address</a> r1, r2;</div>
<div class="line">    std::istringstream ss1(<span class="stringliteral">&quot;255.0.42.42 test&quot;</span>);</div>
<div class="line">    std::istringstream ss2(<span class="stringliteral">&quot;2001:db8:0:0:0:0:0:1%scope test&quot;</span>);</div>
<div class="line">    ss1 &gt;&gt; r1;</div>
<div class="line">    ss2 &gt;&gt; r2;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;has errors: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; (ss1.fail() || ss2.fail()) &lt;&lt; std::endl; <span class="comment">// has errors: false</span></div>
<div class="line">    std::cout &lt;&lt; r1 &lt;&lt; std::endl; <span class="comment">// 255.0.42.42</span></div>
<div class="line">    std::cout &lt;&lt; r2 &lt;&lt; std::endl; <span class="comment">// 2001:db8::1%scope</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classipaddress_1_1ip__network.html">ip_network</a> n1, n2;</div>
<div class="line">    std::istringstream ss3(<span class="stringliteral">&quot;1.2.3.0/16 non strict mode sample&quot;</span>);</div>
<div class="line">    std::istringstream ss4(<span class="stringliteral">&quot;2001:db8::/32 test&quot;</span>);</div>
<div class="line">    ss3 &gt;&gt; non_strict &gt;&gt; n1; <span class="comment">// non strict mode sample</span></div>
<div class="line">    ss4 &gt;&gt; n2;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;has errors: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; (ss3.fail() || ss4.fail()) &lt;&lt; std::endl; <span class="comment">// has errors: false</span></div>
<div class="line">    std::cout &lt;&lt; n1 &lt;&lt; std::endl; <span class="comment">// 1.2.0.0/16</span></div>
<div class="line">    std::cout &lt;&lt; n2 &lt;&lt; std::endl; <span class="comment">// 2001:db8::/32</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassipaddress_1_1ip__address_html"><div class="ttname"><a href="classipaddress_1_1ip__address.html">ipaddress::ip_address</a></div><div class="ttdoc">A class that represents an IP address, supporting both IPv4 and IPv6 formats.</div><div class="ttdef"><b>Definition</b> ip-any-address.hpp:73</div></div>
</div><!-- fragment --><p> 

<div class="cards">

<div class="card">
  <a href="index.html">
  <div class="card_container">
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g id="Arrow / Arrow_Circle_Left"> <path id="Vector" d="M11 9L8 12M8 12L11 15M8 12H16M21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21C16.9706 21 21 16.9706 21 12Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g> </g></svg>
    <h2>Get Started</h2>
    <p>To come back to the beginning.</p>
  </div>
  </a>
</div>

<div class="card">
  <a href="operations.html">
  <div class="card_container">
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g id="Arrow / Arrow_Circle_Right"> <path id="Vector" d="M13 15L16 12M16 12L13 9M16 12H8M21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21C16.9706 21 21 16.9706 21 12Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g> </g></svg>
    <h2>Network Operations</h2>
    <p>To learn about operations and manipulations on networks and address arithmetic.</p>
  </div>
  </a>
</div>

</div>

 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
