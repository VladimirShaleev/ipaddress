<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ipaddress: ipaddress Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/VladimirShaleev/ipaddress" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
  <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
  <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ipaddress<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceipaddress.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ipaddress Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace dedicated to IP addresses and networks operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1base__v4.html">base_v4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class providing the base functionality for IPv4 addresses.  <a href="classipaddress_1_1base__v4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1base__v6.html">base_v6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class providing the base functionality for IPv6 addresses.  <a href="classipaddress_1_1base__v6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipaddress_1_1byte__array.html">byte_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class for creating and managing a fixed-size array of bytes.  <a href="structipaddress_1_1byte__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1error.html">error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary exception class used by the IP address library.  <a href="classipaddress_1_1error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size string class.  <a href="structipaddress_1_1fixed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1hosts__sequence_3_01ip__address__base_3_01Base_01_4_01_4.html">hosts_sequence&lt; ip_address_base&lt; Base &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of host IP addresses.  <a href="classipaddress_1_1hosts__sequence_3_01ip__address__base_3_01Base_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ip__address.html">ip_address</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents an IP address, supporting both IPv4 and IPv6 formats.  <a href="classipaddress_1_1ip__address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ip__address__base.html">ip_address_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template base class for IP address representations.  <a href="classipaddress_1_1ip__address__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ip__address__iterator_3_01ip__address__base_3_01Base_01_4_01_4.html">ip_address_iterator&lt; ip_address_base&lt; Base &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for traversing IP addresses.  <a href="classipaddress_1_1ip__address__iterator_3_01ip__address__base_3_01Base_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ip__network.html">ip_network</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that encapsulates both IPv4 and IPv6 network functionalities.  <a href="classipaddress_1_1ip__network.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template base class for representing a network of IP addresses.  <a href="classipaddress_1_1ip__network__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ip__reverse__iterator.html">ip_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reverse iterator template class for IP addresses.  <a href="classipaddress_1_1ip__reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ipv4__address__base.html">ipv4_address_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for IPv4 address manipulation.  <a href="classipaddress_1_1ipv4__address__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ipv4__network__base.html">ipv4_network_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for IPv4 network address manipulation.  <a href="classipaddress_1_1ipv4__network__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ipv6__address__base.html">ipv6_address_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for IPv6 address manipulation.  <a href="classipaddress_1_1ipv6__address__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1ipv6__network__base.html">ipv6_network_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for IPv6 network address manipulation.  <a href="classipaddress_1_1ipv6__network__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for logical errors in IP address operations.  <a href="classipaddress_1_1logic__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class to manage an optional contained value.  <a href="classipaddress_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1parse__error.html">parse_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for errors encountered during IP address parsing.  <a href="classipaddress_1_1parse__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1scope.html">scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the scope identifier for an IPv6 address.  <a href="classipaddress_1_1scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing a 128-bit unsigned integer.  <a href="classipaddress_1_1uint128__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2314d590d36b6c502b50f1a5d0cf5bcf" id="r_a2314d590d36b6c502b50f1a5d0cf5bcf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2314d590d36b6c502b50f1a5d0cf5bcf">ipv4_address</a> = <a class="el" href="classipaddress_1_1ip__address__base.html">ip_address_base</a>&lt;<a class="el" href="classipaddress_1_1ipv4__address__base.html">ipv4_address_base</a>&gt;</td></tr>
<tr class="memdesc:a2314d590d36b6c502b50f1a5d0cf5bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the base class specialized for IPv4 address manipulation.  <br /></td></tr>
<tr class="separator:a2314d590d36b6c502b50f1a5d0cf5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4392299d63b6ffd13f12fe528f397a3" id="r_af4392299d63b6ffd13f12fe528f397a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> = <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt;<a class="el" href="classipaddress_1_1ipv4__network__base.html">ipv4_network_base</a>&gt;</td></tr>
<tr class="memdesc:af4392299d63b6ffd13f12fe528f397a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the specialized <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class for IPv4.  <br /></td></tr>
<tr class="separator:af4392299d63b6ffd13f12fe528f397a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e072776d657e0e660e387cd493b343f" id="r_a2e072776d657e0e660e387cd493b343f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e072776d657e0e660e387cd493b343f">ipv6_address</a> = <a class="el" href="classipaddress_1_1ip__address__base.html">ip_address_base</a>&lt;<a class="el" href="classipaddress_1_1ipv6__address__base.html">ipv6_address_base</a>&gt;</td></tr>
<tr class="memdesc:a2e072776d657e0e660e387cd493b343f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the base class specialized for IPv6 address manipulation.  <br /></td></tr>
<tr class="separator:a2e072776d657e0e660e387cd493b343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01850d9afb3ea15e8abd25747f61f68" id="r_ac01850d9afb3ea15e8abd25747f61f68"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> = <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt;<a class="el" href="classipaddress_1_1ipv6__network__base.html">ipv6_network_base</a>&gt;</td></tr>
<tr class="memdesc:ac01850d9afb3ea15e8abd25747f61f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the specialized <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class for IPv6.  <br /></td></tr>
<tr class="separator:ac01850d9afb3ea15e8abd25747f61f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88a76ee847c844cc47b94caac600689d" id="r_a88a76ee847c844cc47b94caac600689d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a76ee847c844cc47b94caac600689d">error_code</a> { <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c">NO_ERROR</a> = 0
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689daa278170404490de2776a5db76b560042">EMPTY_ADDRESS</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dafdd90c35444d3fb876602516076b3587">EMPTY_NETMASK</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da962f78fd3b6e6c118d162aeb758e46ad">INVALID_NETMASK</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da40acce788b43717a3a283f7fdcc3fe6d">NETMASK_PATTERN_MIXES_ZEROES_AND_ONES</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689daceae5fc57d94a3e3dc8b7363f465bb30">HAS_HOST_BITS_SET</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da9b0dd645bae34eb17b79da5c94855dba">ONLY_ONE_SLASH_PERMITTED</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dae0e39e65f3844f2ec223ef5f6e4da06a">EMPTY_OCTET</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da88e13ee3330b3ffb9385d77d2a9597d4">EXPECTED_4_OCTETS</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da46e6c7ae8338fb954dffffe2cf6de430">LEADING_0_ARE_NOT_PERMITTED</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da6dd88c745a2fa77cc8cbba26b4adfff6">OCTET_MORE_3_CHARACTERS</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dae5158f71e04b29e7ee269f95176890f4">OCTET_HAS_INVALID_SYMBOL</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da1435adbd5ad33d9489c6351da36eb143">OCTET_EXCEEDED_255</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da6b20b278f4a47ea1933c41afcc6315f0">LEAST_3_PARTS</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da5bb9511a002e2e4dc32cce55b5389ac4">MOST_8_COLONS_PERMITTED</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da1b2d43d909aa3748fb0086af4f885b6b">PART_IS_MORE_4_CHARS</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da0811cb81fdeb9c82cf2d503125435153">PART_HAS_INVALID_SYMBOL</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da94252257499a89afae3e0c7b247efcd5">MOST_ONE_DOUBLE_COLON_PERMITTED</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da38f075bd82c0db96e8a8e1b51f41c5cf">LEADING_COLON_ONLY_PERMITTED_AS_PART_OF_DOUBLE_COLON</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da88a06b88201a7f62966d09b9402e0abc">TRAILING_COLON_ONLY_PERMITTED_AS_PART_OF_DOUBLE_COLON</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689daf4b8e5d9d15659507d6728ab9fe0900f">EXPECTED_AT_MOST_7_OTHER_PARTS_WITH_DOUBLE_COLON</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da8bc2056669746aa3c65f7258352b4f93">EXACTLY_8_PARTS_EXPECTED_WITHOUT_DOUBLE_COLON</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dadfd0dab5f42307e96a5178287989387c">SCOPE_ID_IS_TOO_LONG</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689daa90995871057dca6d3f898acd73938ee">INVALID_SCOPE_ID</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da5f3740fef83818696e8b056c0456173f">INVALID_VERSION</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dafc3a498b8337c66d15dd5723d806ff6e">INVALID_PREFIXLEN_DIFF</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da200869afe81a28a43dc0e1013b1505ba">NEW_PREFIX_MUST_BE_SHORTER</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689dadbc879e336113690f7251a9cb59b8519">NEW_PREFIX_MUST_BE_LONGER</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da52c82f2ae517fb0d130bc306de035039">CANNOT_SET_PREFIXLEN_DIFF_AND_NEW_PREFIX</a>
, <br />
&#160;&#160;<a class="el" href="#a88a76ee847c844cc47b94caac600689da55989913f931071ab5b76da3b3d3bb69">NOT_CONTAINED_NETWORK</a>
<br />
 }</td></tr>
<tr class="memdesc:a88a76ee847c844cc47b94caac600689d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of error codes for IP address parsing and validation.  <a href="#a88a76ee847c844cc47b94caac600689d">More...</a><br /></td></tr>
<tr class="separator:a88a76ee847c844cc47b94caac600689d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b83b8852b7ca0e7e93cbf0034ed69d" id="r_a34b83b8852b7ca0e7e93cbf0034ed69d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b83b8852b7ca0e7e93cbf0034ed69d">ip_version</a> { <br />
&#160;&#160;<a class="el" href="#a34b83b8852b7ca0e7e93cbf0034ed69dab354cab57768c7d4c1106eb4e82c75dc">V4</a> = 4
, <br />
&#160;&#160;<a class="el" href="#a34b83b8852b7ca0e7e93cbf0034ed69dadb93f1c35b844334e2b266951618b4fe">V6</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a34b83b8852b7ca0e7e93cbf0034ed69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the IP address versions.  <a href="#a34b83b8852b7ca0e7e93cbf0034ed69d">More...</a><br /></td></tr>
<tr class="separator:a34b83b8852b7ca0e7e93cbf0034ed69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387137c43ed9616d39ba90e890d181eb" id="r_a387137c43ed9616d39ba90e890d181eb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a387137c43ed9616d39ba90e890d181eb">format</a> { <br />
&#160;&#160;<a class="el" href="#a387137c43ed9616d39ba90e890d181ebae9dc924f238fa6cc29465942875fe8f0">full</a> = 0
, <br />
&#160;&#160;<a class="el" href="#a387137c43ed9616d39ba90e890d181eba7cf74ca49c304df8150205fc915cd465">compact</a>
, <br />
&#160;&#160;<a class="el" href="#a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672">compressed</a>
<br />
 }</td></tr>
<tr class="memdesc:a387137c43ed9616d39ba90e890d181eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the formatting options for IP address strings.  <a href="#a387137c43ed9616d39ba90e890d181eb">More...</a><br /></td></tr>
<tr class="separator:a387137c43ed9616d39ba90e890d181eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae152906605a801e881781467fbc0ef27" id="r_ae152906605a801e881781467fbc0ef27"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ae152906605a801e881781467fbc0ef27"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae152906605a801e881781467fbc0ef27">operator==</a> (const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae152906605a801e881781467fbc0ef27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are equal.  <br /></td></tr>
<tr class="separator:ae152906605a801e881781467fbc0ef27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c5dec8ed16e157eab5a1417d70b190" id="r_a18c5dec8ed16e157eab5a1417d70b190"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a18c5dec8ed16e157eab5a1417d70b190"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18c5dec8ed16e157eab5a1417d70b190">operator!=</a> (const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a18c5dec8ed16e157eab5a1417d70b190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are not equal.  <br /></td></tr>
<tr class="separator:a18c5dec8ed16e157eab5a1417d70b190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe7cf9a5b3dd7d5ecd303b05e7a74e" id="r_ac0fe7cf9a5b3dd7d5ecd303b05e7a74e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac0fe7cf9a5b3dd7d5ecd303b05e7a74e"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0fe7cf9a5b3dd7d5ecd303b05e7a74e">operator&lt;</a> (const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac0fe7cf9a5b3dd7d5ecd303b05e7a74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is less than another.  <br /></td></tr>
<tr class="separator:ac0fe7cf9a5b3dd7d5ecd303b05e7a74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0d2145a802a73bfbc2348f1e19a9f5" id="r_a1a0d2145a802a73bfbc2348f1e19a9f5"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a1a0d2145a802a73bfbc2348f1e19a9f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a0d2145a802a73bfbc2348f1e19a9f5">operator&gt;</a> (const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1a0d2145a802a73bfbc2348f1e19a9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is greater than another.  <br /></td></tr>
<tr class="separator:a1a0d2145a802a73bfbc2348f1e19a9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88391db8f21b65518e89fb131a3b9e7e" id="r_a88391db8f21b65518e89fb131a3b9e7e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a88391db8f21b65518e89fb131a3b9e7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88391db8f21b65518e89fb131a3b9e7e">operator&lt;=</a> (const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a88391db8f21b65518e89fb131a3b9e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is less than or equal to another.  <br /></td></tr>
<tr class="separator:a88391db8f21b65518e89fb131a3b9e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40459ce900575e6fcd3575109f519e42" id="r_a40459ce900575e6fcd3575109f519e42"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a40459ce900575e6fcd3575109f519e42"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40459ce900575e6fcd3575109f519e42">operator&gt;=</a> (const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a40459ce900575e6fcd3575109f519e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is greater than or equal to another.  <br /></td></tr>
<tr class="separator:a40459ce900575e6fcd3575109f519e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c2188b3ff3f049f12f54d2d739c5fd" id="r_a81c2188b3ff3f049f12f54d2d739c5fd"><td class="memItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81c2188b3ff3f049f12f54d2d739c5fd">is_little_endian</a> () noexcept</td></tr>
<tr class="memdesc:a81c2188b3ff3f049f12f54d2d739c5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the system is little-endian.  <br /></td></tr>
<tr class="separator:a81c2188b3ff3f049f12f54d2d739c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524c25b69b6d182168edce0d93387de" id="r_af524c25b69b6d182168edce0d93387de"><td class="memItemLeft" align="right" valign="top">constexpr inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af524c25b69b6d182168edce0d93387de">swap_bytes</a> (uint32_t value) noexcept</td></tr>
<tr class="memdesc:af524c25b69b6d182168edce0d93387de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the bytes of a 32-bit unsigned integer.  <br /></td></tr>
<tr class="separator:af524c25b69b6d182168edce0d93387de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e22b2f60d8491d05a7457fdc9d33cb" id="r_a72e22b2f60d8491d05a7457fdc9d33cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72e22b2f60d8491d05a7457fdc9d33cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72e22b2f60d8491d05a7457fdc9d33cb">raise_error</a> (<a class="el" href="#a88a76ee847c844cc47b94caac600689d">error_code</a> code, int index, const T *address, size_t length)</td></tr>
<tr class="memdesc:a72e22b2f60d8491d05a7457fdc9d33cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises an error with a specific error code and additional context.  <br /></td></tr>
<tr class="separator:a72e22b2f60d8491d05a7457fdc9d33cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01042455e8ed031c0612794c3aef4df" id="r_af01042455e8ed031c0612794c3aef4df"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:af01042455e8ed031c0612794c3aef4df"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af01042455e8ed031c0612794c3aef4df">operator==</a> (const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af01042455e8ed031c0612794c3aef4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two fixed strings for equality.  <br /></td></tr>
<tr class="separator:af01042455e8ed031c0612794c3aef4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4da60b88e6ad823cbb3393eddf2ecc4" id="r_af4da60b88e6ad823cbb3393eddf2ecc4"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:af4da60b88e6ad823cbb3393eddf2ecc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4da60b88e6ad823cbb3393eddf2ecc4">operator!=</a> (const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af4da60b88e6ad823cbb3393eddf2ecc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two fixed strings for inequality.  <br /></td></tr>
<tr class="separator:af4da60b88e6ad823cbb3393eddf2ecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b755fa3e4a0e6578cab8394b6363243" id="r_a8b755fa3e4a0e6578cab8394b6363243"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:a8b755fa3e4a0e6578cab8394b6363243"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b755fa3e4a0e6578cab8394b6363243">operator&lt;</a> (const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8b755fa3e4a0e6578cab8394b6363243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two fixed strings lexicographically.  <br /></td></tr>
<tr class="separator:a8b755fa3e4a0e6578cab8394b6363243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374f69580e0ce86fb820fe3317cecae2" id="r_a374f69580e0ce86fb820fe3317cecae2"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:a374f69580e0ce86fb820fe3317cecae2"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a374f69580e0ce86fb820fe3317cecae2">operator&gt;</a> (const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a374f69580e0ce86fb820fe3317cecae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two fixed strings for greater than relation.  <br /></td></tr>
<tr class="separator:a374f69580e0ce86fb820fe3317cecae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace73f059f10698e321bdfd42d87eabe1" id="r_ace73f059f10698e321bdfd42d87eabe1"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:ace73f059f10698e321bdfd42d87eabe1"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace73f059f10698e321bdfd42d87eabe1">operator&lt;=</a> (const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ace73f059f10698e321bdfd42d87eabe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two fixed strings for less than or equal relation.  <br /></td></tr>
<tr class="separator:ace73f059f10698e321bdfd42d87eabe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360bfae1b01e3c0766bf24bcda9a6044" id="r_a360bfae1b01e3c0766bf24bcda9a6044"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:a360bfae1b01e3c0766bf24bcda9a6044"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a360bfae1b01e3c0766bf24bcda9a6044">operator&gt;=</a> (const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;lhs, const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a360bfae1b01e3c0766bf24bcda9a6044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two fixed strings for greater than or equal relation.  <br /></td></tr>
<tr class="separator:a360bfae1b01e3c0766bf24bcda9a6044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956dd9046c069d47d5d075c553a3db01" id="r_a956dd9046c069d47d5d075c553a3db01"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a956dd9046c069d47d5d075c553a3db01"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a956dd9046c069d47d5d075c553a3db01">make_fixed_string</a> (const char(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a956dd9046c069d47d5d075c553a3db01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fixed-length string from a character array.  <br /></td></tr>
<tr class="separator:a956dd9046c069d47d5d075c553a3db01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3a8a140d928f4a80e5e286b4029659" id="r_a8d3a8a140d928f4a80e5e286b4029659"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a8d3a8a140d928f4a80e5e286b4029659"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d3a8a140d928f4a80e5e286b4029659">make_fixed_string</a> (const wchar_t(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a8d3a8a140d928f4a80e5e286b4029659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fixed-length string from a wide character array.  <br /></td></tr>
<tr class="separator:a8d3a8a140d928f4a80e5e286b4029659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d595119c8954a137eaba3ef8c1aa4a" id="r_a29d595119c8954a137eaba3ef8c1aa4a"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a29d595119c8954a137eaba3ef8c1aa4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29d595119c8954a137eaba3ef8c1aa4a">make_fixed_string</a> (const char16_t(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:a29d595119c8954a137eaba3ef8c1aa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fixed-length string from a UTF-16 character array.  <br /></td></tr>
<tr class="separator:a29d595119c8954a137eaba3ef8c1aa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec817d6ec31f7efcf06902c35f7cce50" id="r_aec817d6ec31f7efcf06902c35f7cce50"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:aec817d6ec31f7efcf06902c35f7cce50"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec817d6ec31f7efcf06902c35f7cce50">make_fixed_string</a> (const char32_t(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:aec817d6ec31f7efcf06902c35f7cce50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fixed-length string from a UTF-32 character array.  <br /></td></tr>
<tr class="separator:aec817d6ec31f7efcf06902c35f7cce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff00fe84d95c3b275ffacf39ee81df34" id="r_aff00fe84d95c3b275ffacf39ee81df34"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:aff00fe84d95c3b275ffacf39ee81df34"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff00fe84d95c3b275ffacf39ee81df34">make_fixed_string</a> (const char8_t(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:aff00fe84d95c3b275ffacf39ee81df34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fixed-length string from a UTF-8 character array.  <br /></td></tr>
<tr class="separator:aff00fe84d95c3b275ffacf39ee81df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd586286b0af2efef1fabf74378195d1" id="r_abd586286b0af2efef1fabf74378195d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </td></tr>
<tr class="memitem:abd586286b0af2efef1fabf74378195d1"><td class="memTemplItemLeft" align="right" valign="top">consteval inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd586286b0af2efef1fabf74378195d1">operator&quot;&quot;_ip</a> () noexcept</td></tr>
<tr class="memdesc:abd586286b0af2efef1fabf74378195d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for creating an <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a> from a fixed string at compile time.  <br /></td></tr>
<tr class="separator:abd586286b0af2efef1fabf74378195d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d70e54be5cc16f330aa4d508d11600" id="r_a56d70e54be5cc16f330aa4d508d11600"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </td></tr>
<tr class="memitem:a56d70e54be5cc16f330aa4d508d11600"><td class="memTemplItemLeft" align="right" valign="top">consteval inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56d70e54be5cc16f330aa4d508d11600">operator&quot;&quot;_net</a> () noexcept</td></tr>
<tr class="memdesc:a56d70e54be5cc16f330aa4d508d11600"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal operator for creating an <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object from a string literal.  <br /></td></tr>
<tr class="separator:a56d70e54be5cc16f330aa4d508d11600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2402f2fe67431aa1c900c1602b791b5" id="r_ad2402f2fe67431aa1c900c1602b791b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </td></tr>
<tr class="memitem:ad2402f2fe67431aa1c900c1602b791b5"><td class="memTemplItemLeft" align="right" valign="top">consteval inline <a class="el" href="#a2314d590d36b6c502b50f1a5d0cf5bcf">ipv4_address</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2402f2fe67431aa1c900c1602b791b5">operator&quot;&quot;_ipv4</a> () noexcept</td></tr>
<tr class="memdesc:ad2402f2fe67431aa1c900c1602b791b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for creating an ipv4_address from a fixed string at compile time.  <br /></td></tr>
<tr class="separator:ad2402f2fe67431aa1c900c1602b791b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d6e1e500b8adedd862335fd8fb5fe5" id="r_a71d6e1e500b8adedd862335fd8fb5fe5"><td class="memItemLeft" align="right" valign="top">consteval inline <a class="el" href="#a2314d590d36b6c502b50f1a5d0cf5bcf">ipv4_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71d6e1e500b8adedd862335fd8fb5fe5">operator&quot;&quot;_ipv4</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:a71d6e1e500b8adedd862335fd8fb5fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for creating an ipv4_address from an unsigned long long integer at compile time.  <br /></td></tr>
<tr class="separator:a71d6e1e500b8adedd862335fd8fb5fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8a4e9db4ee847c92376a7108fa576c" id="r_a4c8a4e9db4ee847c92376a7108fa576c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </td></tr>
<tr class="memitem:a4c8a4e9db4ee847c92376a7108fa576c"><td class="memTemplItemLeft" align="right" valign="top">consteval inline <a class="el" href="#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c8a4e9db4ee847c92376a7108fa576c">operator&quot;&quot;_ipv4_net</a> () noexcept</td></tr>
<tr class="memdesc:a4c8a4e9db4ee847c92376a7108fa576c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal operator for creating an ipv4_network object from a string literal.  <br /></td></tr>
<tr class="separator:a4c8a4e9db4ee847c92376a7108fa576c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a7ca990af72b116c12f6b5e4a0537" id="r_a745a7ca990af72b116c12f6b5e4a0537"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </td></tr>
<tr class="memitem:a745a7ca990af72b116c12f6b5e4a0537"><td class="memTemplItemLeft" align="right" valign="top">consteval inline <a class="el" href="#a2e072776d657e0e660e387cd493b343f">ipv6_address</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a745a7ca990af72b116c12f6b5e4a0537">operator&quot;&quot;_ipv6</a> () noexcept</td></tr>
<tr class="memdesc:a745a7ca990af72b116c12f6b5e4a0537"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for creating an ipv6_address from a fixed string at compile time.  <br /></td></tr>
<tr class="separator:a745a7ca990af72b116c12f6b5e4a0537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e653376242842495c4c74d56d5ecc95" id="r_a4e653376242842495c4c74d56d5ecc95"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </td></tr>
<tr class="memitem:a4e653376242842495c4c74d56d5ecc95"><td class="memTemplItemLeft" align="right" valign="top">consteval inline <a class="el" href="#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e653376242842495c4c74d56d5ecc95">operator&quot;&quot;_ipv6_net</a> () noexcept</td></tr>
<tr class="memdesc:a4e653376242842495c4c74d56d5ecc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal operator for creating an ipv6_network object from a string literal.  <br /></td></tr>
<tr class="separator:a4e653376242842495c4c74d56d5ecc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e717b351c0d6bbb85956933c94749e7" id="r_a2e717b351c0d6bbb85956933c94749e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a2e717b351c0d6bbb85956933c94749e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e717b351c0d6bbb85956933c94749e7">operator+</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a2e717b351c0d6bbb85956933c94749e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs addition between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a2e717b351c0d6bbb85956933c94749e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55162b8d8b89e400346dabe757e75541" id="r_a55162b8d8b89e400346dabe757e75541"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a55162b8d8b89e400346dabe757e75541"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55162b8d8b89e400346dabe757e75541">operator-</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a55162b8d8b89e400346dabe757e75541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs subtraction of a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value from an integer.  <br /></td></tr>
<tr class="separator:a55162b8d8b89e400346dabe757e75541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed916ca5ca55c61031d4554ee46804a9" id="r_aed916ca5ca55c61031d4554ee46804a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:aed916ca5ca55c61031d4554ee46804a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed916ca5ca55c61031d4554ee46804a9">operator*</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aed916ca5ca55c61031d4554ee46804a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multiplication between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:aed916ca5ca55c61031d4554ee46804a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a17341b08fce9e9dcf805669b02972" id="r_af5a17341b08fce9e9dcf805669b02972"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:af5a17341b08fce9e9dcf805669b02972"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5a17341b08fce9e9dcf805669b02972">operator/</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:af5a17341b08fce9e9dcf805669b02972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs division of an integer by a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:af5a17341b08fce9e9dcf805669b02972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8004dcb48763969cc526a12084db3238" id="r_a8004dcb48763969cc526a12084db3238"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a8004dcb48763969cc526a12084db3238"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8004dcb48763969cc526a12084db3238">operator%</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a8004dcb48763969cc526a12084db3238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the remainder of division of an integer by a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a8004dcb48763969cc526a12084db3238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c19bbd960875277cf07f59d77f398ff" id="r_a7c19bbd960875277cf07f59d77f398ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a7c19bbd960875277cf07f59d77f398ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c19bbd960875277cf07f59d77f398ff">operator&amp;</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a7c19bbd960875277cf07f59d77f398ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise AND operation between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a7c19bbd960875277cf07f59d77f398ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257494f2b7a8b18520e757667143c113" id="r_a257494f2b7a8b18520e757667143c113"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a257494f2b7a8b18520e757667143c113"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a257494f2b7a8b18520e757667143c113">operator|</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a257494f2b7a8b18520e757667143c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise OR operation between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a257494f2b7a8b18520e757667143c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a74e0d720767cf12fd7dafeef47f8c7" id="r_a1a74e0d720767cf12fd7dafeef47f8c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a1a74e0d720767cf12fd7dafeef47f8c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a74e0d720767cf12fd7dafeef47f8c7">operator^</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a1a74e0d720767cf12fd7dafeef47f8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise XOR operation between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a1a74e0d720767cf12fd7dafeef47f8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa765d67f1454052197cc20778b5ea728" id="r_aa765d67f1454052197cc20778b5ea728"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:aa765d67f1454052197cc20778b5ea728"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa765d67f1454052197cc20778b5ea728">operator==</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aa765d67f1454052197cc20778b5ea728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an integer value is equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:aa765d67f1454052197cc20778b5ea728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac739f2b09aa55e6f9767566b23d67e13" id="r_ac739f2b09aa55e6f9767566b23d67e13"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:ac739f2b09aa55e6f9767566b23d67e13"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac739f2b09aa55e6f9767566b23d67e13">operator!=</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ac739f2b09aa55e6f9767566b23d67e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an integer value is not equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:ac739f2b09aa55e6f9767566b23d67e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5185e4b81c8f00e79c354502b1c92b75" id="r_a5185e4b81c8f00e79c354502b1c92b75"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a5185e4b81c8f00e79c354502b1c92b75"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5185e4b81c8f00e79c354502b1c92b75">operator&lt;</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a5185e4b81c8f00e79c354502b1c92b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if an integer value is less than a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a5185e4b81c8f00e79c354502b1c92b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d4cd3d6307d647b18de0538950f4c3" id="r_a43d4cd3d6307d647b18de0538950f4c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a43d4cd3d6307d647b18de0538950f4c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43d4cd3d6307d647b18de0538950f4c3">operator&gt;</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a43d4cd3d6307d647b18de0538950f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if an integer value is greater than a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:a43d4cd3d6307d647b18de0538950f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e3ec3726faa86909427c11bc162e89" id="r_ae0e3ec3726faa86909427c11bc162e89"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:ae0e3ec3726faa86909427c11bc162e89"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0e3ec3726faa86909427c11bc162e89">operator&lt;=</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ae0e3ec3726faa86909427c11bc162e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if an integer value is less than or equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:ae0e3ec3726faa86909427c11bc162e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eed2f03da4df1da93e93b309abb596" id="r_ac4eed2f03da4df1da93e93b309abb596"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:ac4eed2f03da4df1da93e93b309abb596"><td class="memTemplItemLeft" align="right" valign="top">constexpr inline bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4eed2f03da4df1da93e93b309abb596">operator&gt;=</a> (T lower, const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ac4eed2f03da4df1da93e93b309abb596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if an integer value is greater than or equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.  <br /></td></tr>
<tr class="separator:ac4eed2f03da4df1da93e93b309abb596"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace dedicated to IP addresses and networks operations. </p>
<p>This namespace contains all the classes, functions, and utilities necessary for handling both IPv4 and IPv6 addresses and networks. It provides a comprehensive suite of tools for various operations such as parsing, constructing, and manipulating IP addresses and networks. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a2314d590d36b6c502b50f1a5d0cf5bcf" name="a2314d590d36b6c502b50f1a5d0cf5bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2314d590d36b6c502b50f1a5d0cf5bcf">&#9670;&#160;</a></span>ipv4_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2314d590d36b6c502b50f1a5d0cf5bcf">ipv4_address</a> = <a class="el" href="classipaddress_1_1ip__address__base.html">ip_address_base</a>&lt;<a class="el" href="classipaddress_1_1ipv4__address__base.html">ipv4_address_base</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the base class specialized for IPv4 address manipulation. </p>
<p>This alias provides a convenient shorthand for the specialized <code><a class="el" href="classipaddress_1_1ip__address__base.html" title="A template base class for IP address representations.">ip_address_base</a></code> class tailored for IPv4 address handling. It inherits all functionalities from the <code><a class="el" href="classipaddress_1_1ipv4__address__base.html" title="Represents the base class for IPv4 address manipulation.">ipv4_address_base</a></code> class, allowing for operations such as conversion, comparison, and property querying specific to IPv4 addresses. </p>

</div>
</div>
<a id="af4392299d63b6ffd13f12fe528f397a3" name="af4392299d63b6ffd13f12fe528f397a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4392299d63b6ffd13f12fe528f397a3">&#9670;&#160;</a></span>ipv4_network</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> = <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt;<a class="el" href="classipaddress_1_1ipv4__network__base.html">ipv4_network_base</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the specialized <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class for IPv4. </p>
<p>The ipv4_network is a convenient alias for the <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class specialized with <a class="el" href="classipaddress_1_1ipv4__network__base.html" title="Base class for IPv4 network address manipulation.">ipv4_network_base</a>. It allows users to work with IPv4 network addresses using a type that is specifically designed for IPv4, simplifying the interface and usage in code that deals with IPv4 networks. </p>

</div>
</div>
<a id="a2e072776d657e0e660e387cd493b343f" name="a2e072776d657e0e660e387cd493b343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e072776d657e0e660e387cd493b343f">&#9670;&#160;</a></span>ipv6_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2e072776d657e0e660e387cd493b343f">ipv6_address</a> = <a class="el" href="classipaddress_1_1ip__address__base.html">ip_address_base</a>&lt;<a class="el" href="classipaddress_1_1ipv6__address__base.html">ipv6_address_base</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the base class specialized for IPv6 address manipulation. </p>
<p>This alias provides a convenient shorthand for the specialized <code><a class="el" href="classipaddress_1_1ip__address__base.html" title="A template base class for IP address representations.">ip_address_base</a></code> class tailored for IPv6 address handling. It inherits all functionalities from the <code><a class="el" href="classipaddress_1_1ipv6__address__base.html" title="Represents the base class for IPv6 address manipulation.">ipv6_address_base</a></code> class, allowing for operations such as conversion, comparison, and property querying specific to IPv6 addresses. </p>

</div>
</div>
<a id="ac01850d9afb3ea15e8abd25747f61f68" name="ac01850d9afb3ea15e8abd25747f61f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01850d9afb3ea15e8abd25747f61f68">&#9670;&#160;</a></span>ipv6_network</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> = <a class="el" href="classipaddress_1_1ip__network__base.html">ip_network_base</a>&lt;<a class="el" href="classipaddress_1_1ipv6__network__base.html">ipv6_network_base</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the specialized <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class for IPv6. </p>
<p>The ipv6_network is a convenient alias for the <a class="el" href="classipaddress_1_1ip__network__base.html" title="Template base class for representing a network of IP addresses.">ip_network_base</a> class specialized with <a class="el" href="classipaddress_1_1ipv6__network__base.html" title="Base class for IPv6 network address manipulation.">ipv6_network_base</a>. It allows users to work with IPv6 network addresses using a type that is specifically designed for IPv6, simplifying the interface and usage in code that deals with IPv6 networks. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a88a76ee847c844cc47b94caac600689d" name="a88a76ee847c844cc47b94caac600689d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a76ee847c844cc47b94caac600689d">&#9670;&#160;</a></span>error_code</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a88a76ee847c844cc47b94caac600689d">error_code</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of error codes for IP address parsing and validation. </p>
<p>This enumeration defines a set of error codes used to represent various error conditions that can occur during the parsing and validation of IP addresses. These error codes are used to provide detailed feedback about the nature of the error encountered, allowing for more precise error handling and troubleshooting.</p>
<p>The error codes are divided into several categories:</p><ul>
<li>General errors related to the overall format and structure of the IP address.</li>
<li>IPv4-specific errors that address the unique syntactical requirements of IPv4 addresses.</li>
<li>IPv6-specific errors that address the unique syntactical requirements of IPv6 addresses.</li>
<li>Logical errors that represent inconsistencies or invalid operations in network calculations.</li>
</ul>
<p>Each error code is accompanied by a brief comment explaining the specific error condition it represents. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c" name="a88a76ee847c844cc47b94caac600689dad306b6fdee05fe87455110ddf6501e6c"></a>NO_ERROR&#160;</td><td class="fielddoc"><p>Indicates the absence of any errors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689daa278170404490de2776a5db76b560042" name="a88a76ee847c844cc47b94caac600689daa278170404490de2776a5db76b560042"></a>EMPTY_ADDRESS&#160;</td><td class="fielddoc"><p>The IP address string is empty when it should contain a valid address. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dafdd90c35444d3fb876602516076b3587" name="a88a76ee847c844cc47b94caac600689dafdd90c35444d3fb876602516076b3587"></a>EMPTY_NETMASK&#160;</td><td class="fielddoc"><p>The netmask portion of the address is empty when it should specify a valid netmask. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da962f78fd3b6e6c118d162aeb758e46ad" name="a88a76ee847c844cc47b94caac600689da962f78fd3b6e6c118d162aeb758e46ad"></a>INVALID_NETMASK&#160;</td><td class="fielddoc"><p>The provided netmask is not valid according to standard netmask formatting rules. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da40acce788b43717a3a283f7fdcc3fe6d" name="a88a76ee847c844cc47b94caac600689da40acce788b43717a3a283f7fdcc3fe6d"></a>NETMASK_PATTERN_MIXES_ZEROES_AND_ONES&#160;</td><td class="fielddoc"><p>The netmask contains an invalid pattern of zeroes and ones. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689daceae5fc57d94a3e3dc8b7363f465bb30" name="a88a76ee847c844cc47b94caac600689daceae5fc57d94a3e3dc8b7363f465bb30"></a>HAS_HOST_BITS_SET&#160;</td><td class="fielddoc"><p>The address has host bits set when they are expected to be clear. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da9b0dd645bae34eb17b79da5c94855dba" name="a88a76ee847c844cc47b94caac600689da9b0dd645bae34eb17b79da5c94855dba"></a>ONLY_ONE_SLASH_PERMITTED&#160;</td><td class="fielddoc"><p>Only one slash character is permitted, used to separate the address from the netmask. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dae0e39e65f3844f2ec223ef5f6e4da06a" name="a88a76ee847c844cc47b94caac600689dae0e39e65f3844f2ec223ef5f6e4da06a"></a>EMPTY_OCTET&#160;</td><td class="fielddoc"><p>An octet in the IPv4 address is empty when it should contain a numeric value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da88e13ee3330b3ffb9385d77d2a9597d4" name="a88a76ee847c844cc47b94caac600689da88e13ee3330b3ffb9385d77d2a9597d4"></a>EXPECTED_4_OCTETS&#160;</td><td class="fielddoc"><p>The IPv4 address does not contain the expected four octets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da46e6c7ae8338fb954dffffe2cf6de430" name="a88a76ee847c844cc47b94caac600689da46e6c7ae8338fb954dffffe2cf6de430"></a>LEADING_0_ARE_NOT_PERMITTED&#160;</td><td class="fielddoc"><p>Leading zeroes are not permitted in any octet of the IPv4 address. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da6dd88c745a2fa77cc8cbba26b4adfff6" name="a88a76ee847c844cc47b94caac600689da6dd88c745a2fa77cc8cbba26b4adfff6"></a>OCTET_MORE_3_CHARACTERS&#160;</td><td class="fielddoc"><p>An octet contains more than three characters, exceeding the maximum allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dae5158f71e04b29e7ee269f95176890f4" name="a88a76ee847c844cc47b94caac600689dae5158f71e04b29e7ee269f95176890f4"></a>OCTET_HAS_INVALID_SYMBOL&#160;</td><td class="fielddoc"><p>An octet contains characters other than digits, which are invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da1435adbd5ad33d9489c6351da36eb143" name="a88a76ee847c844cc47b94caac600689da1435adbd5ad33d9489c6351da36eb143"></a>OCTET_EXCEEDED_255&#160;</td><td class="fielddoc"><p>An octet's value exceeds the maximum allowed value of 255. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da6b20b278f4a47ea1933c41afcc6315f0" name="a88a76ee847c844cc47b94caac600689da6b20b278f4a47ea1933c41afcc6315f0"></a>LEAST_3_PARTS&#160;</td><td class="fielddoc"><p>The IPv6 address contains fewer than the minimum required parts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da5bb9511a002e2e4dc32cce55b5389ac4" name="a88a76ee847c844cc47b94caac600689da5bb9511a002e2e4dc32cce55b5389ac4"></a>MOST_8_COLONS_PERMITTED&#160;</td><td class="fielddoc"><p>The IPv6 address contains more than the maximum allowed number of colons. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da1b2d43d909aa3748fb0086af4f885b6b" name="a88a76ee847c844cc47b94caac600689da1b2d43d909aa3748fb0086af4f885b6b"></a>PART_IS_MORE_4_CHARS&#160;</td><td class="fielddoc"><p>A part of the IPv6 address contains more than four characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da0811cb81fdeb9c82cf2d503125435153" name="a88a76ee847c844cc47b94caac600689da0811cb81fdeb9c82cf2d503125435153"></a>PART_HAS_INVALID_SYMBOL&#160;</td><td class="fielddoc"><p>A part of the IPv6 address contains invalid characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da94252257499a89afae3e0c7b247efcd5" name="a88a76ee847c844cc47b94caac600689da94252257499a89afae3e0c7b247efcd5"></a>MOST_ONE_DOUBLE_COLON_PERMITTED&#160;</td><td class="fielddoc"><p>More than one double colon is present in the IPv6 address. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da38f075bd82c0db96e8a8e1b51f41c5cf" name="a88a76ee847c844cc47b94caac600689da38f075bd82c0db96e8a8e1b51f41c5cf"></a>LEADING_COLON_ONLY_PERMITTED_AS_PART_OF_DOUBLE_COLON&#160;</td><td class="fielddoc"><p>A leading colon is only permitted as part of a double colon. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da88a06b88201a7f62966d09b9402e0abc" name="a88a76ee847c844cc47b94caac600689da88a06b88201a7f62966d09b9402e0abc"></a>TRAILING_COLON_ONLY_PERMITTED_AS_PART_OF_DOUBLE_COLON&#160;</td><td class="fielddoc"><p>A trailing colon is only permitted as part of a double colon. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689daf4b8e5d9d15659507d6728ab9fe0900f" name="a88a76ee847c844cc47b94caac600689daf4b8e5d9d15659507d6728ab9fe0900f"></a>EXPECTED_AT_MOST_7_OTHER_PARTS_WITH_DOUBLE_COLON&#160;</td><td class="fielddoc"><p>With a double colon present, at most seven other parts are expected. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da8bc2056669746aa3c65f7258352b4f93" name="a88a76ee847c844cc47b94caac600689da8bc2056669746aa3c65f7258352b4f93"></a>EXACTLY_8_PARTS_EXPECTED_WITHOUT_DOUBLE_COLON&#160;</td><td class="fielddoc"><p>Without a double colon, exactly eight parts are expected. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dadfd0dab5f42307e96a5178287989387c" name="a88a76ee847c844cc47b94caac600689dadfd0dab5f42307e96a5178287989387c"></a>SCOPE_ID_IS_TOO_LONG&#160;</td><td class="fielddoc"><p>The scope ID in the IPv6 address exceeds the maximum length. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689daa90995871057dca6d3f898acd73938ee" name="a88a76ee847c844cc47b94caac600689daa90995871057dca6d3f898acd73938ee"></a>INVALID_SCOPE_ID&#160;</td><td class="fielddoc"><p>The scope ID in the IPv6 address is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da5f3740fef83818696e8b056c0456173f" name="a88a76ee847c844cc47b94caac600689da5f3740fef83818696e8b056c0456173f"></a>INVALID_VERSION&#160;</td><td class="fielddoc"><p>The IP address version does not match the expected version. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dafc3a498b8337c66d15dd5723d806ff6e" name="a88a76ee847c844cc47b94caac600689dafc3a498b8337c66d15dd5723d806ff6e"></a>INVALID_PREFIXLEN_DIFF&#160;</td><td class="fielddoc"><p>The difference in prefix length is invalid for the operation being performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da200869afe81a28a43dc0e1013b1505ba" name="a88a76ee847c844cc47b94caac600689da200869afe81a28a43dc0e1013b1505ba"></a>NEW_PREFIX_MUST_BE_SHORTER&#160;</td><td class="fielddoc"><p>The new prefix length must be shorter for the operation being performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689dadbc879e336113690f7251a9cb59b8519" name="a88a76ee847c844cc47b94caac600689dadbc879e336113690f7251a9cb59b8519"></a>NEW_PREFIX_MUST_BE_LONGER&#160;</td><td class="fielddoc"><p>The new prefix length must be longer for the operation being performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da52c82f2ae517fb0d130bc306de035039" name="a88a76ee847c844cc47b94caac600689da52c82f2ae517fb0d130bc306de035039"></a>CANNOT_SET_PREFIXLEN_DIFF_AND_NEW_PREFIX&#160;</td><td class="fielddoc"><p>Both prefix length difference and new prefix cannot be set simultaneously. </p>
</td></tr>
<tr><td class="fieldname"><a id="a88a76ee847c844cc47b94caac600689da55989913f931071ab5b76da3b3d3bb69" name="a88a76ee847c844cc47b94caac600689da55989913f931071ab5b76da3b3d3bb69"></a>NOT_CONTAINED_NETWORK&#160;</td><td class="fielddoc"><p>The network is not a subnet of the other network as expected. </p>
</td></tr>
</table>

</div>
</div>
<a id="a34b83b8852b7ca0e7e93cbf0034ed69d" name="a34b83b8852b7ca0e7e93cbf0034ed69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b83b8852b7ca0e7e93cbf0034ed69d">&#9670;&#160;</a></span>ip_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a34b83b8852b7ca0e7e93cbf0034ed69d">ip_version</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the IP address versions. </p>
<p>Defines constants representing the two versions of Internet Protocol: IPv4 and IPv6. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34b83b8852b7ca0e7e93cbf0034ed69dab354cab57768c7d4c1106eb4e82c75dc" name="a34b83b8852b7ca0e7e93cbf0034ed69dab354cab57768c7d4c1106eb4e82c75dc"></a>V4&#160;</td><td class="fielddoc"><p>IPv4 version identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34b83b8852b7ca0e7e93cbf0034ed69dadb93f1c35b844334e2b266951618b4fe" name="a34b83b8852b7ca0e7e93cbf0034ed69dadb93f1c35b844334e2b266951618b4fe"></a>V6&#160;</td><td class="fielddoc"><p>IPv6 version identifier. </p>
</td></tr>
</table>

</div>
</div>
<a id="a387137c43ed9616d39ba90e890d181eb" name="a387137c43ed9616d39ba90e890d181eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387137c43ed9616d39ba90e890d181eb">&#9670;&#160;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a387137c43ed9616d39ba90e890d181eb">format</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the formatting options for IP address strings. </p>
<p>Defines the formatting styles that can be applied when converting IP addresses to strings, such as full, compact, or compressed representations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181ebae9dc924f238fa6cc29465942875fe8f0" name="a387137c43ed9616d39ba90e890d181ebae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>Full format with no compression or omission. </p>
</td></tr>
<tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181eba7cf74ca49c304df8150205fc915cd465" name="a387137c43ed9616d39ba90e890d181eba7cf74ca49c304df8150205fc915cd465"></a>compact&#160;</td><td class="fielddoc"><p>Compact format with possible omission of leading zeros. </p>
</td></tr>
<tr><td class="fieldname"><a id="a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672" name="a387137c43ed9616d39ba90e890d181eba2b98a4ad988a18c42682f388901f2672"></a>compressed&#160;</td><td class="fielddoc"><p>Compressed format with maximal omission of segments or octets. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae152906605a801e881781467fbc0ef27" name="ae152906605a801e881781467fbc0ef27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae152906605a801e881781467fbc0ef27">&#9670;&#160;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are equal. </p>
<p>Compares two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects of the same size element-wise to determine if they are equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the byte array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A reference to the left-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A reference to the right-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether the two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are equal. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are equal </td></tr>
    <tr><td class="paramname">false</td><td>the two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are not equal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18c5dec8ed16e157eab5a1417d70b190" name="a18c5dec8ed16e157eab5a1417d70b190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c5dec8ed16e157eab5a1417d70b190">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are not equal. </p>
<p>Compares two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects of the same size element-wise to determine if they are not equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the byte array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A reference to the left-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A reference to the right-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value indicating whether the two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are not equal. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are not equal </td></tr>
    <tr><td class="paramname">false</td><td>the two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects are equal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0fe7cf9a5b3dd7d5ecd303b05e7a74e" name="ac0fe7cf9a5b3dd7d5ecd303b05e7a74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fe7cf9a5b3dd7d5ecd303b05e7a74e">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is less than another. </p>
<p>Performs a lexicographical comparison of two <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> objects. The comparison is done element-wise and stops at the first unequal pair where the left-hand side is less than the right-hand side.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A reference to the left-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A reference to the right-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lhs is lexicographically less than rhs, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1a0d2145a802a73bfbc2348f1e19a9f5" name="a1a0d2145a802a73bfbc2348f1e19a9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0d2145a802a73bfbc2348f1e19a9f5">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is greater than another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A reference to the left-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A reference to the right-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lhs is lexicographically greater than rhs, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a88391db8f21b65518e89fb131a3b9e7e" name="a88391db8f21b65518e89fb131a3b9e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88391db8f21b65518e89fb131a3b9e7e">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is less than or equal to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A reference to the left-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A reference to the right-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lhs is lexicographically less than or equal to rhs, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a40459ce900575e6fcd3575109f519e42" name="a40459ce900575e6fcd3575109f519e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40459ce900575e6fcd3575109f519e42">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1byte__array.html">byte_array</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if one <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> is greater than or equal to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A reference to the left-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A reference to the right-hand side <a class="el" href="structipaddress_1_1byte__array.html" title="A template class for creating and managing a fixed-size array of bytes.">byte_array</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lhs is lexicographically greater than or equal to rhs, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a81c2188b3ff3f049f12f54d2d739c5fd" name="a81c2188b3ff3f049f12f54d2d739c5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c2188b3ff3f049f12f54d2d739c5fd">&#9670;&#160;</a></span>is_little_endian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool is_little_endian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the system is little-endian. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the system is little-endian, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af524c25b69b6d182168edce0d93387de" name="af524c25b69b6d182168edce0d93387de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524c25b69b6d182168edce0d93387de">&#9670;&#160;</a></span>swap_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline uint32_t swap_bytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the bytes of a 32-bit unsigned integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer value to swap bytes of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value with its bytes swapped. </dd></dl>

</div>
</div>
<a id="a72e22b2f60d8491d05a7457fdc9d33cb" name="a72e22b2f60d8491d05a7457fdc9d33cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e22b2f60d8491d05a7457fdc9d33cb">&#9670;&#160;</a></span>raise_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void raise_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a88a76ee847c844cc47b94caac600689d">error_code</a></td>          <td class="paramname"><span class="paramname"><em>code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>address</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises an error with a specific error code and additional context. </p>
<p>This function constructs an error message based on the provided error code, index, and address, then throws a <a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a> or a <a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a> exception with the constructed message.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The character type of the address string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The error code indicating the type of error encountered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index at which the error occurred, if applicable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A pointer to the beginning of the address string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the address string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1parse__error.html" title="Exception for errors encountered during IP address parsing.">parse_error</a></td><td>Thrown with a message corresponding to the error code. </td></tr>
    <tr><td class="paramname"><a class="el" href="classipaddress_1_1logic__error.html" title="Exception for logical errors in IP address operations.">logic_error</a></td><td>Thrown with a message corresponding to the error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is marked [[noreturn]] as it always throws an exception. </dd></dl>

</div>
</div>
<a id="af01042455e8ed031c0612794c3aef4df" name="af01042455e8ed031c0612794c3aef4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01042455e8ed031c0612794c3aef4df">&#9670;&#160;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two fixed strings for equality. </p>
<p>Checks if the contents of <em>lhs</em> and <em>rhs</em> are equal, meaning they have the same number of elements and each element in <em>lhs</em> compares equal with the element in <em>rhs</em> at the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N1</td><td>The maximum number of characters of <em>lhs</em>. </td></tr>
    <tr><td class="paramname">N2</td><td>The maximum number of characters of <em>rhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The fixed string whose contents to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The fixed string whose contents to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of the strings are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af4da60b88e6ad823cbb3393eddf2ecc4" name="af4da60b88e6ad823cbb3393eddf2ecc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4da60b88e6ad823cbb3393eddf2ecc4">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two fixed strings for inequality. </p>
<p>Checks if the contents of <em>lhs</em> and <em>rhs</em> are not equal, meaning they do not have the same number of elements or there is at least one position at which the elements in <em>lhs</em> and <em>rhs</em> differ.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N1</td><td>The maximum number of characters of <em>lhs</em>. </td></tr>
    <tr><td class="paramname">N2</td><td>The maximum number of characters of <em>rhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The fixed string whose contents to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The fixed string whose contents to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of the strings are not equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8b755fa3e4a0e6578cab8394b6363243" name="a8b755fa3e4a0e6578cab8394b6363243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b755fa3e4a0e6578cab8394b6363243">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two fixed strings lexicographically. </p>
<p>Checks if the contents of <em>lhs</em> are lexicographically less than the contents of <em>rhs</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N1</td><td>The maximum number of characters of <em>lhs</em>. </td></tr>
    <tr><td class="paramname">N2</td><td>The maximum number of characters of <em>rhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The fixed string whose contents to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The fixed string whose contents to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of <em>lhs</em> are lexicographically less than the contents of <em>rhs</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a374f69580e0ce86fb820fe3317cecae2" name="a374f69580e0ce86fb820fe3317cecae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374f69580e0ce86fb820fe3317cecae2">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two fixed strings for greater than relation. </p>
<p>Determines if the contents of <em>lhs</em> are lexicographically greater than the contents of <em>rhs</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N1</td><td>The maximum number of characters of <em>lhs</em>. </td></tr>
    <tr><td class="paramname">N2</td><td>The maximum number of characters of <em>rhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The fixed string whose contents to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The fixed string whose contents to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lhs</em> is lexicographically greater than <em>rhs</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ace73f059f10698e321bdfd42d87eabe1" name="ace73f059f10698e321bdfd42d87eabe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace73f059f10698e321bdfd42d87eabe1">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two fixed strings for less than or equal relation. </p>
<p>Determines if the contents of <em>lhs</em> are lexicographically less than or equal to the contents of <em>rhs</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N1</td><td>The maximum number of characters of <em>lhs</em>. </td></tr>
    <tr><td class="paramname">N2</td><td>The maximum number of characters of <em>rhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The fixed string whose contents to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The fixed string whose contents to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lhs</em> is lexicographically less than or equal to <em>rhs</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a360bfae1b01e3c0766bf24bcda9a6044" name="a360bfae1b01e3c0766bf24bcda9a6044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360bfae1b01e3c0766bf24bcda9a6044">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two fixed strings for greater than or equal relation. </p>
<p>Determines if the contents of <em>lhs</em> are lexicographically greater than or equal to the contents of <em>rhs</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N1</td><td>The maximum number of characters of <em>lhs</em>. </td></tr>
    <tr><td class="paramname">N2</td><td>The maximum number of characters of <em>rhs</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The fixed string whose contents to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The fixed string whose contents to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lhs</em> is lexicographically greater than or equal to <em>rhs</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a956dd9046c069d47d5d075c553a3db01" name="a956dd9046c069d47d5d075c553a3db01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956dd9046c069d47d5d075c553a3db01">&#9670;&#160;</a></span>make_fixed_string() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt; make_fixed_string </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fixed-length string from a character array. </p>
<p>Constructs a <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object from a character array, deducing the size automatically.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the character array plus one for the null terminator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The character array to initialize the <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object of size N-1. </dd></dl>

</div>
</div>
<a id="a8d3a8a140d928f4a80e5e286b4029659" name="a8d3a8a140d928f4a80e5e286b4029659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3a8a140d928f4a80e5e286b4029659">&#9670;&#160;</a></span>make_fixed_string() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt; make_fixed_string </td>
          <td>(</td>
          <td class="paramtype">const wchar_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fixed-length string from a wide character array. </p>
<p>Constructs a <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object from a wide character array, deducing the size automatically.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the wide character array plus one for the null terminator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The wide character array to initialize the <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object of size N-1. </dd></dl>

</div>
</div>
<a id="a29d595119c8954a137eaba3ef8c1aa4a" name="a29d595119c8954a137eaba3ef8c1aa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d595119c8954a137eaba3ef8c1aa4a">&#9670;&#160;</a></span>make_fixed_string() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt; make_fixed_string </td>
          <td>(</td>
          <td class="paramtype">const char16_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fixed-length string from a UTF-16 character array. </p>
<p>Constructs a <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object from a UTF-16 character array, deducing the size automatically.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the UTF-16 character array plus one for the null terminator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The UTF-16 character array to initialize the <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object of size N-1. </dd></dl>

</div>
</div>
<a id="aec817d6ec31f7efcf06902c35f7cce50" name="aec817d6ec31f7efcf06902c35f7cce50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec817d6ec31f7efcf06902c35f7cce50">&#9670;&#160;</a></span>make_fixed_string() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt; make_fixed_string </td>
          <td>(</td>
          <td class="paramtype">const char32_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fixed-length string from a UTF-32 character array. </p>
<p>Constructs a <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object from a UTF-32 character array, deducing the size automatically.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the UTF-32 character array plus one for the null terminator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The UTF-32 character array to initialize the <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object of size N-1. </dd></dl>

</div>
</div>
<a id="aff00fe84d95c3b275ffacf39ee81df34" name="aff00fe84d95c3b275ffacf39ee81df34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff00fe84d95c3b275ffacf39ee81df34">&#9670;&#160;</a></span>make_fixed_string() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a>&lt; N - 1 &gt; make_fixed_string </td>
          <td>(</td>
          <td class="paramtype">const char8_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em>[N]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fixed-length string from a UTF-8 character array. </p>
<p>Constructs a <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object from a UTF-8 character array, deducing the size automatically.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the UTF-8 character array plus one for the null terminator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The UTF-8 character array to initialize the <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structipaddress_1_1fixed__string.html" title="Fixed size string class.">fixed_string</a> object of size N-1. </dd></dl>

</div>
</div>
<a id="abd586286b0af2efef1fabf74378195d1" name="abd586286b0af2efef1fabf74378195d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd586286b0af2efef1fabf74378195d1">&#9670;&#160;</a></span>operator&quot;&quot;_ip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="classipaddress_1_1ip__address.html">ip_address</a> operator&quot;&quot;_ip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal for creating an <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a> from a fixed string at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A compile-time fixed string representing the IPv6 address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classipaddress_1_1ip__address.html" title="A class that represents an IP address, supporting both IPv4 and IPv6 formats.">ip_address</a> object parsed from the fixed string. </dd></dl>

</div>
</div>
<a id="a56d70e54be5cc16f330aa4d508d11600" name="a56d70e54be5cc16f330aa4d508d11600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d70e54be5cc16f330aa4d508d11600">&#9670;&#160;</a></span>operator&quot;&quot;_net()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="classipaddress_1_1ip__network.html">ip_network</a> operator&quot;&quot;_net </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal operator for creating an <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object from a string literal. </p>
<p>This operator allows the creation of <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> objects using a string literal with the <code>_net</code> suffix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A string literal representing the IP network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classipaddress_1_1ip__network.html" title="A class that encapsulates both IPv4 and IPv6 network functionalities.">ip_network</a> object representing the network specified by the string literal. </dd></dl>

</div>
</div>
<a id="ad2402f2fe67431aa1c900c1602b791b5" name="ad2402f2fe67431aa1c900c1602b791b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2402f2fe67431aa1c900c1602b791b5">&#9670;&#160;</a></span>operator&quot;&quot;_ipv4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="#a2314d590d36b6c502b50f1a5d0cf5bcf">ipv4_address</a> operator&quot;&quot;_ipv4 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal for creating an ipv4_address from a fixed string at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A compile-time fixed string representing the IPv4 address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ipv4_address object parsed from the fixed string. </dd></dl>

</div>
</div>
<a id="a71d6e1e500b8adedd862335fd8fb5fe5" name="a71d6e1e500b8adedd862335fd8fb5fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d6e1e500b8adedd862335fd8fb5fe5">&#9670;&#160;</a></span>operator&quot;&quot;_ipv4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="#a2314d590d36b6c502b50f1a5d0cf5bcf">ipv4_address</a> operator&quot;&quot;_ipv4 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal for creating an ipv4_address from an unsigned long long integer at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>An unsigned long long integer representing the IPv4 address in <em>host byte order</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ipv4_address object created from the integer. </dd></dl>

</div>
</div>
<a id="a4c8a4e9db4ee847c92376a7108fa576c" name="a4c8a4e9db4ee847c92376a7108fa576c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8a4e9db4ee847c92376a7108fa576c">&#9670;&#160;</a></span>operator&quot;&quot;_ipv4_net()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="#af4392299d63b6ffd13f12fe528f397a3">ipv4_network</a> operator&quot;&quot;_ipv4_net </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal operator for creating an ipv4_network object from a string literal. </p>
<p>This operator allows the creation of ipv4_network objects using a string literal with the <code>_ipv4_net</code> suffix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A string literal representing the IPv4 network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ipv4_network object representing the network specified by the string literal. </dd></dl>

</div>
</div>
<a id="a745a7ca990af72b116c12f6b5e4a0537" name="a745a7ca990af72b116c12f6b5e4a0537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745a7ca990af72b116c12f6b5e4a0537">&#9670;&#160;</a></span>operator&quot;&quot;_ipv6()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="#a2e072776d657e0e660e387cd493b343f">ipv6_address</a> operator&quot;&quot;_ipv6 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal for creating an ipv6_address from a fixed string at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A compile-time fixed string representing the IPv6 address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ipv6_address object parsed from the fixed string. </dd></dl>

</div>
</div>
<a id="a4e653376242842495c4c74d56d5ecc95" name="a4e653376242842495c4c74d56d5ecc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e653376242842495c4c74d56d5ecc95">&#9670;&#160;</a></span>operator&quot;&quot;_ipv6_net()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structipaddress_1_1fixed__string.html">fixed_string</a> FixedString&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval inline <a class="el" href="#ac01850d9afb3ea15e8abd25747f61f68">ipv6_network</a> operator&quot;&quot;_ipv6_net </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined literal operator for creating an ipv6_network object from a string literal. </p>
<p>This operator allows the creation of ipv6_network objects using a string literal with the <code>_ipv6_net</code> suffix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedString</td><td>A string literal representing the IPv6 network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ipv6_network object representing the network specified by the string literal. </dd></dl>

</div>
</div>
<a id="a2e717b351c0d6bbb85956933c94749e7" name="a2e717b351c0d6bbb85956933c94749e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e717b351c0d6bbb85956933c94749e7">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs addition between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the addition. </dd></dl>

</div>
</div>
<a id="a55162b8d8b89e400346dabe757e75541" name="a55162b8d8b89e400346dabe757e75541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55162b8d8b89e400346dabe757e75541">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator- </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs subtraction of a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value from an integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value from which the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value is subtracted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the subtraction. </dd></dl>

</div>
</div>
<a id="aed916ca5ca55c61031d4554ee46804a9" name="aed916ca5ca55c61031d4554ee46804a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed916ca5ca55c61031d4554ee46804a9">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator* </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs multiplication between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value to be multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the multiplication. </dd></dl>

</div>
</div>
<a id="af5a17341b08fce9e9dcf805669b02972" name="af5a17341b08fce9e9dcf805669b02972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a17341b08fce9e9dcf805669b02972">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs division of an integer by a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value to be divided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value that divides the integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the division. </dd></dl>

</div>
</div>
<a id="a8004dcb48763969cc526a12084db3238" name="a8004dcb48763969cc526a12084db3238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8004dcb48763969cc526a12084db3238">&#9670;&#160;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator% </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the remainder of division of an integer by a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value to be divided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value that divides the integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the remainder of the division. </dd></dl>

</div>
</div>
<a id="a7c19bbd960875277cf07f59d77f398ff" name="a7c19bbd960875277cf07f59d77f398ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c19bbd960875277cf07f59d77f398ff">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator&amp; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs bitwise AND operation between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the bitwise AND operation. </dd></dl>

</div>
</div>
<a id="a257494f2b7a8b18520e757667143c113" name="a257494f2b7a8b18520e757667143c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257494f2b7a8b18520e757667143c113">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator| </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs bitwise OR operation between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the bitwise OR operation. </dd></dl>

</div>
</div>
<a id="a1a74e0d720767cf12fd7dafeef47f8c7" name="a1a74e0d720767cf12fd7dafeef47f8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a74e0d720767cf12fd7dafeef47f8c7">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> operator^ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs bitwise XOR operation between an integer and a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> the result of the bitwise XOR operation. </dd></dl>

</div>
</div>
<a id="aa765d67f1454052197cc20778b5ea728" name="aa765d67f1454052197cc20778b5ea728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa765d67f1454052197cc20778b5ea728">&#9670;&#160;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator== </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an integer value is equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the integer value is equal to the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac739f2b09aa55e6f9767566b23d67e13" name="ac739f2b09aa55e6f9767566b23d67e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac739f2b09aa55e6f9767566b23d67e13">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator!= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an integer value is not equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the integer value is not equal to the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5185e4b81c8f00e79c354502b1c92b75" name="a5185e4b81c8f00e79c354502b1c92b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5185e4b81c8f00e79c354502b1c92b75">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if an integer value is less than a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<p>This function template overloads the less than operator (&lt;) to compare an integer of type T with a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. It checks if the integer value is lexicographically less than the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integral type parameter that is checked at compile-time to ensure it is an integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value of type T to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lower</em> is less than <em>other</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a43d4cd3d6307d647b18de0538950f4c3" name="a43d4cd3d6307d647b18de0538950f4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d4cd3d6307d647b18de0538950f4c3">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if an integer value is greater than a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<p>This function template overloads the greater than operator (&gt;) to compare an integer of type T with a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. It checks if the integer value is lexicographically greater than the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integral type parameter that is checked at compile-time to ensure it is an integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value of type T to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lower</em> is greater than <em>other</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae0e3ec3726faa86909427c11bc162e89" name="ae0e3ec3726faa86909427c11bc162e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e3ec3726faa86909427c11bc162e89">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if an integer value is less than or equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<p>This function template overloads the less than or equal to operator (&lt;=) to compare an integer of type T with a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. It checks if the integer value is lexicographically less than or equal to the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integral type parameter that is checked at compile-time to ensure it is an integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value of type T to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lower</em> is less than or equal to <em>other</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac4eed2f03da4df1da93e93b309abb596" name="ac4eed2f03da4df1da93e93b309abb596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eed2f03da4df1da93e93b309abb596">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr inline bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>lower</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipaddress_1_1uint128__t.html">uint128_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares if an integer value is greater than or equal to a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. </p>
<p>This function template overloads the greater than or equal to operator (&gt;=) to compare an integer of type T with a <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value. It checks if the integer value is lexicographically greater than or equal to the <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integral type parameter that is checked at compile-time to ensure it is an integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The integer value of type T to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classipaddress_1_1uint128__t.html" title="Class for representing a 128-bit unsigned integer.">uint128_t</a> value to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>lower</em> is greater than or equal to <em>other</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceipaddress.html">ipaddress</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
